<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Network | 忐忑の博客</title><link>https://twbhub.com/tags/network/</link><atom:link href="https://twbhub.com/tags/network/index.xml" rel="self" type="application/rss+xml"/><description>Network</description><generator>Wowchemy (https://wowchemy.com)</generator><language>zh-Hans</language><copyright>[![忐忑的博客](https://img.shields.io/badge/©-2020%20%2D-%202023_忐忑-yellow)](/authors/admin/) [![忐忑的博客](https://img.shields.io/github/tag/twbworld/twbworld.GitHub.io?logo=github)](https://github.com/twbworld/twbworld.GitHub.io) [![Hugo](https://img.shields.io/badge/powered-hugo-ff4088?logo=hugo)](https://gohugo.io/) [![wowchemy](https://img.shields.io/badge/theme-wowchemy-00d1b2)](https://wowchemy.com/)</copyright><lastBuildDate>Sun, 02 Oct 2022 17:00:00 +0800</lastBuildDate><image><url>https://twbhub.com/media/avatar.jpg</url><title>Network</title><link>https://twbhub.com/tags/network/</link></image><item><title>nginx开启stream模块获取真实ip</title><link>https://twbhub.com/post/get_real_ip/</link><pubDate>Mon, 14 Mar 2022 21:00:00 +0800</pubDate><guid>https://twbhub.com/post/get_real_ip/</guid><description>&lt;blockquote>
&lt;p>nginx开了stream模块,无法获取想要的客户端ip,最近学习了相关知识, 顺带做笔记&lt;/p>
&lt;/blockquote>
&lt;h2 id="几个重要知识点">几个重要知识点&lt;/h2>
&lt;ol>
&lt;li>&lt;code>X-Forwarded-For&lt;/code> 和 &lt;code>X-Real-IP&lt;/code> 是http的请求头,属于第七层网络;意味两者的数据都可伪造篡改&lt;/li>
&lt;li>&lt;code>remote_addr&lt;/code> 是tcp发起端的ip地址, 属于第四层网络(&lt;code>Ip-Port&lt;/code>), 意味着无法伪造也不为空(否则服务器与客户端就无法传输数据了)&lt;/li>
&lt;li>默认情况下, 发起http请求的客户端, 是不会把 本机的ip 写到 &lt;code>X-Forwarded-For&lt;/code> 和 &lt;code>X-Real-IP&lt;/code> 请求头里的, 而是把 &lt;code>remote_addr&lt;/code>(上一节点的客户端的ip地址, 没节点就为空)替换掉&lt;code>X-Real-IP&lt;/code> 和拼接到 &lt;code>X-Forwarded-For&lt;/code>后, 再发起http请求&lt;/li>
&lt;li>根据 &lt;code>3&lt;/code> 知识点, 可看出 &lt;code>X-Real-IP&lt;/code> 是单个ip地址, &lt;code>X-Forwarded-For&lt;/code>是一串ip(&amp;quot;,&amp;ldquo;相隔)&lt;/li>
&lt;li>服务器收到的 &lt;code>X-Forwarded-For&lt;/code> 和 &lt;code>X-Real-IP&lt;/code>, 在没有代理的情况下,值一般为空;&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="上机测试">上机测试&lt;/h2>
&lt;h3 id="测试一">测试一&lt;/h3>
&lt;p>假设由A发起http请求, 直接访问服务器 B; 如下 :&lt;/p>
&lt;p>A(1.1.1.1) -&amp;gt; B(2.2.2.2)&lt;/p>
&lt;blockquote>
&lt;p>B nginx为什么要开启stream模块? 因为可以做四层负载均衡 和 对tls流量进行分流, 这方面相关知识不细讲了, 这里简化了配置,去掉四层负载均衡和tls分流相关配置&lt;/p>
&lt;/blockquote>
&lt;p>B的nginx配置如下:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="color:#75715e">#四层网络
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">stream&lt;/span> {
&lt;span style="color:#f92672">server&lt;/span> {
&lt;span style="color:#f92672">listen&lt;/span> 2.2.2.2:&lt;span style="color:#ae81ff">443&lt;/span>;
&lt;span style="color:#f92672">proxy_pass&lt;/span> 127.0.0.1:&lt;span style="color:#ae81ff">443&lt;/span>; &lt;span style="color:#75715e">#代理给http层
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">ssl_preread&lt;/span> &lt;span style="color:#66d9ef">on&lt;/span>;
}
}
&lt;span style="color:#75715e">#七层网络
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">http&lt;/span> {
&lt;span style="color:#f92672">log_format&lt;/span> &lt;span style="color:#e6db74">httplog&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&lt;/span>$remote_addr|$http_x_real_ip|$http_x_forwarded_for&amp;#39;;
&lt;span style="color:#f92672">server&lt;/span> {
&lt;span style="color:#f92672">listen&lt;/span> 127.0.0.1:&lt;span style="color:#ae81ff">443&lt;/span> &lt;span style="color:#e6db74">ssl&lt;/span>;
&lt;span style="color:#f92672">server_name&lt;/span> &lt;span style="color:#e6db74">test.com&lt;/span>;
&lt;span style="color:#f92672">access_log&lt;/span> &lt;span style="color:#e6db74">access.log&lt;/span> &lt;span style="color:#e6db74">httplog&lt;/span>;
&lt;span style="color:#f92672">......&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;span style="color:#e6db74">......&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>A发起http请求, nginx日志:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">127.0.0.1|-|-
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>&lt;code>X-Real-IP&lt;/code>和&lt;code>X-Forwarded-For&lt;/code>为空很好理解,因为中间没有代理; 但为何&lt;code>remote_addr&lt;/code>不是预想中的&lt;code>1.1.1.1&lt;/code>呢?&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>是因为stream配置的关系, 根据&lt;a href="#%e5%87%a0%e4%b8%aa%e9%87%8d%e8%a6%81%e7%9f%a5%e8%af%86%e7%82%b9">&lt;code>知识点2&lt;/code>&lt;/a>, remote_addr是上一节点的tcp真实ip, 而stream正是处理四层网络数据的, 换而言之&lt;code>stream&lt;/code>就相当于一层&amp;quot;代理&amp;rdquo;, 所以http获取到的remote_addr地址其实是&lt;code>stream&lt;/code>模块的ip, 即&amp;quot;127.0.0.1&amp;quot;&lt;/li>
&lt;li>如果在stream模块下记录remote_addr日志,得到的正是&amp;quot;1.1.1.1&amp;quot;, 不信你试试&lt;/li>
&lt;li>根据&lt;a href="#%e5%87%a0%e4%b8%aa%e9%87%8d%e8%a6%81%e7%9f%a5%e8%af%86%e7%82%b9">&lt;code>知识点1&lt;/code>&lt;/a> &lt;code>X-Real-IP&lt;/code>和&lt;code>X-Forwarded-For&lt;/code>是http请求头,那就是下阶段的http流了, stream管不着, 自然这俩像预想中一样为空了&lt;/li>
&lt;/ul>
&lt;p>那么怎么解决这个问题呢? 获取的remote_addr&amp;quot;127.0.0.1&amp;quot;而不是真实ip&lt;/p>
&lt;h4 id="解决">解决&lt;/h4>
&lt;p>配置改为如下:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="color:#75715e">#四层网络
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">stream&lt;/span> {
&lt;span style="color:#f92672">server&lt;/span> {
&lt;span style="color:#f92672">listen&lt;/span> 2.2.2.2:&lt;span style="color:#ae81ff">443&lt;/span>;
&lt;span style="color:#f92672">proxy_pass&lt;/span> 127.0.0.1:&lt;span style="color:#ae81ff">443&lt;/span>; &lt;span style="color:#75715e">#代理给http层
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">ssl_preread&lt;/span> &lt;span style="color:#66d9ef">on&lt;/span>;
&lt;span style="color:#f92672">proxy_protocol&lt;/span> &lt;span style="color:#66d9ef">on&lt;/span>; &lt;span style="color:#75715e">#开启protocol
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
}
&lt;span style="color:#75715e">#七层网络
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">http&lt;/span> {
&lt;span style="color:#f92672">log_format&lt;/span> &lt;span style="color:#e6db74">httplog&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&lt;/span>$remote_addr|$http_x_real_ip|$http_x_forwarded_for|$proxy_protocol_addr&amp;#39;;
&lt;span style="color:#f92672">server&lt;/span> {
&lt;span style="color:#f92672">listen&lt;/span> 127.0.0.1:&lt;span style="color:#ae81ff">443&lt;/span> &lt;span style="color:#e6db74">ssl&lt;/span> &lt;span style="color:#e6db74">proxy_protocol&lt;/span>; &lt;span style="color:#75715e">#接收protocol数据
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">server_name&lt;/span> &lt;span style="color:#e6db74">test.com&lt;/span>;
&lt;span style="color:#75715e">#以下三行用于修改$remote_addr变量(remote_addr是不能被上一节点修改,但获得remote_addr后是可在本机(nginx)内部修改的,注意两者概念哟)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">#别看配置名其中有&amp;#34;real_ip&amp;#34;,实质作用于remote_addr
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">real_ip_recursive&lt;/span> &lt;span style="color:#66d9ef">on&lt;/span>;
&lt;span style="color:#f92672">real_ip_header&lt;/span> &lt;span style="color:#e6db74">proxy_protocol&lt;/span>; &lt;span style="color:#75715e">#基于stream层传来protocol数据进行后续修改
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">set_real_ip_from&lt;/span> &lt;span style="color:#ae81ff">127&lt;/span>&lt;span style="color:#e6db74">.0.0.0/24&lt;/span>; &lt;span style="color:#75715e">#从real_ip_header中删除这个ip段的ip,也可直接写具体ip;
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#f92672">access_log&lt;/span> &lt;span style="color:#e6db74">access.log&lt;/span> &lt;span style="color:#e6db74">httplog&lt;/span>;
&lt;span style="color:#f92672">location&lt;/span> &lt;span style="color:#e6db74">/&lt;/span> {
&lt;span style="color:#f92672">proxy_pass&lt;/span> &lt;span style="color:#e6db74">http://3.3.3.3:443&lt;/span>;
&lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">X-Real-IP&lt;/span> $remote_addr; &lt;span style="color:#75715e">#把处理后的$remote_addr赋值给http请求头X-Real-IP, 便于下一级服务获取真实ip
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">X-Forwarded-For&lt;/span> $remote_addr;
&lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">Host&lt;/span> $host;
&lt;span style="color:#f92672">......&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;span style="color:#e6db74">......&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;span style="color:#e6db74">......&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>A发起http请求, nginx日志:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">1.1.1.1|-|-|1.1.1.1
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>成功获取真实ip; 可以看到$proxy_protocol_addr也能获取到A真实ip,使用&lt;code>proxy_set_header X-Real-IP $proxy_protocol_addr&lt;/code>也是可以的&lt;/p>
&lt;/blockquote>
&lt;h3 id="测试二">测试二&lt;/h3>
&lt;p>假设由A发起http请求, B作为代理, 到达服务器C; 如下 :&lt;/p>
&lt;p>A(1.1.1.1) -&amp;gt; B(2.2.2.2) -&amp;gt; C(3.3.3.3)&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="#%e6%b5%8b%e8%af%95%e4%b8%80">测试一&lt;/a>的B服务nginx配置不变; 以下测试服务C,同样开启stream(与 &lt;code>测试一&lt;/code> 配置大体不变)&lt;/p>
&lt;/blockquote>
&lt;p>C的nginx配置如下:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-nginx" data-lang="nginx">&lt;span style="color:#75715e">#四层网络
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">stream&lt;/span> {
&lt;span style="color:#f92672">server&lt;/span> {
&lt;span style="color:#f92672">listen&lt;/span> 3.3.3.3:&lt;span style="color:#ae81ff">443&lt;/span>;
&lt;span style="color:#f92672">proxy_pass&lt;/span> 127.0.0.1:&lt;span style="color:#ae81ff">443&lt;/span>; &lt;span style="color:#75715e">#代理给http层
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">ssl_preread&lt;/span> &lt;span style="color:#66d9ef">on&lt;/span>;
&lt;span style="color:#f92672">proxy_protocol&lt;/span> &lt;span style="color:#66d9ef">on&lt;/span>; &lt;span style="color:#75715e">#开启protocol
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
}
&lt;span style="color:#75715e">#七层网络
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">http&lt;/span> {
&lt;span style="color:#f92672">log_format&lt;/span> &lt;span style="color:#e6db74">httplog&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&lt;/span>$remote_addr|$http_x_real_ip|$http_x_forwarded_for|$proxy_protocol_addr&amp;#39;;
&lt;span style="color:#f92672">server&lt;/span> {
&lt;span style="color:#f92672">listen&lt;/span> 127.0.0.1:&lt;span style="color:#ae81ff">443&lt;/span> &lt;span style="color:#e6db74">ssl&lt;/span> &lt;span style="color:#e6db74">proxy_protocol&lt;/span>;
&lt;span style="color:#f92672">server_name&lt;/span> &lt;span style="color:#e6db74">test.com&lt;/span>;
&lt;span style="color:#f92672">real_ip_recursive&lt;/span> &lt;span style="color:#66d9ef">on&lt;/span>;
&lt;span style="color:#f92672">real_ip_header&lt;/span> &lt;span style="color:#e6db74">proxy_protocol&lt;/span>; &lt;span style="color:#75715e">#可选值: proxy_protocol/X-Forwarded-For/CF-Connecting-IP(如用了cloudflare代理)等
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">set_real_ip_from&lt;/span> &lt;span style="color:#ae81ff">127&lt;/span>&lt;span style="color:#e6db74">.0.0.0/24&lt;/span>;
&lt;span style="color:#f92672">set_real_ip_from&lt;/span> &lt;span style="color:#ae81ff">172&lt;/span>&lt;span style="color:#e6db74">.1.0.0/16&lt;/span>;
&lt;span style="color:#75715e">#还可添加代理商的ip列表(官网查); 如cloudflare: https://www.cloudflare.com/ips/
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#f92672">access_log&lt;/span> &lt;span style="color:#e6db74">access.log&lt;/span> &lt;span style="color:#e6db74">httplog&lt;/span>;
&lt;span style="color:#f92672">location&lt;/span> &lt;span style="color:#e6db74">/&lt;/span> {
&lt;span style="color:#f92672">proxy_pass&lt;/span> &lt;span style="color:#e6db74">http://4.4.4.4:443&lt;/span>;
&lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">X-Real-IP&lt;/span> $remote_addr;
&lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">X-Forwarded-For&lt;/span> $remote_addr;
&lt;span style="color:#f92672">proxy_set_header&lt;/span> &lt;span style="color:#e6db74">Host&lt;/span> $host;
&lt;span style="color:#f92672">......&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;span style="color:#e6db74">......&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;span style="color:#e6db74">......&lt;/span>
&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>A发起http请求, C的nginx日志:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">2.2.2.2|1.1.1.1|1.1.1.1|2.2.2.2
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>毫无疑问, C成功获取到A的真实ip; 其中$remote_addr为上级ip; 而$http_x_real_ip和$http_x_forwarded_for是代理B发起的http请求头传过来的; 一切预料之中&lt;/p>
&lt;/blockquote>
&lt;p>&lt;em>&lt;strong>举一反三, 就算后边有再多的代理节点, 也可以正常获取真实ip的&lt;/strong>&lt;/em>&lt;/p></description></item><item><title>Postman无法抓包Chrome</title><link>https://twbhub.com/post/postman_cannot_connection_chrome/</link><pubDate>Thu, 20 May 2021 23:00:00 +0800</pubDate><guid>https://twbhub.com/post/postman_cannot_connection_chrome/</guid><description>&lt;h2 id="原因">原因&lt;/h2>
&lt;p>Mac安装了两个版本(我的是正式版和&lt;code>Dev&lt;/code>版)的 &lt;code>Chrome&lt;/code> ,一个正常, 另一个版本无法与 &lt;code>Postman&lt;/code> 连接, 无法被抓包(Windows不会出现这样的情况)
原因是不正常的版本缺少了一个 &lt;code>Interceptor&lt;/code> 插件的配置文件, 据官方&lt;a href="https://learning.postman.com/docs/sending-requests/capturing-request-data/interceptor/#how-it-works" target="_blank" rel="noopener">文档&lt;/a>所述,文件位于
&lt;code>/Users/&amp;lt;username&amp;gt;/Library/Application Support/Google/Chrome/NativeMessagingHosts/com.postman.postmanapp.json&lt;/code>&lt;/p>
&lt;h2 id="解决">解决&lt;/h2>
&lt;p>也简单,配置文件位于 正式版的 &lt;code>Chrome&lt;/code> 下, 解决方法就是复制一份到对应的版本的 &lt;code>Chrome&lt;/code> 的对应目录下
如复制文件到Dev版的 &lt;code>Chrome&lt;/code>对应目录: &lt;code>/Users/&amp;lt;username&amp;gt;/Library/Application Support/Google/Chrome Dev/NativeMessagingHosts/com.postman.postmanapp.json&lt;/code>&lt;/p></description></item><item><title>Postman抓包https</title><link>https://twbhub.com/post/postman_capture_https/</link><pubDate>Thu, 20 May 2021 22:00:00 +0800</pubDate><guid>https://twbhub.com/post/postman_capture_https/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;blockquote>
&lt;p>虽然会使用 &lt;code>Charles&lt;/code>(花瓶) , 但如果 &lt;code>Postman&lt;/code> 也可以实相同的功能, 少用一个工具, 那谁能不爱呢, 借 &lt;code>Postman&lt;/code> 强大的发包功能, 就更方便了&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>今天要讲的是, 抓取iOS的https包(Android7以后, 只能获取Root权限才能安装并信任CA证书, 所以就不以Android为例了)&lt;/p>
&lt;/blockquote>
&lt;h2 id="安装并信任证书">安装并信任证书&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>安装Postman后, 根据&lt;a href="https://learning.postman.com/docs/sending-requests/capturing-request-data/capturing-http-requests/#macos" target="_blank" rel="noopener">文档&lt;/a>的指示, Postman的CA证书位于
Mac: &lt;code>~/Library/Application Support/Postman/proxy/postman-proxy-ca.crt&lt;/code>
Windows: &lt;code>C:\Users&amp;lt;user&amp;gt;\AppData\Roaming\Postman\proxy/postman-proxy-ca.crt&lt;/code>
&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20210520225920.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>找到证书后,想办法把证书传到iOS, 并打开, iOS会识别并提示
打开 &lt;code>设置=&amp;gt;通用=&amp;gt;描述文件&lt;/code> , 可以看到一个 &lt;code>已下载&lt;/code> 但未安装的证书, 安装就好
&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20210520230353.jpeg" alt="">
&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20210520230534.jpeg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>安装完证书,还要让iOS信任该证书
打开 &lt;code>设置=&amp;gt;通用=&amp;gt;关于本机=&amp;gt;证书信任设置&lt;/code> 找到对应的Postman证书并开启信任
&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20210520231655.png" alt="">&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="设置代理并抓包">设置代理并抓包&lt;/h2>
&lt;p>到此,后面的步骤就也就不难了,网上也有不少教程,在此不详解&lt;/p>
&lt;ol>
&lt;li>在Mac或Windows上的Postman开启代理,设置端口(Windows需安装openSSL)&lt;/li>
&lt;li>iOS与Mac或Windows连接同一个网络(WIFI)&lt;/li>
&lt;li>打开iOS的WiFI页, &lt;code>配置手动代理&lt;/code>, 填写Mac或Windows的IP地址和前一步设置的端口&lt;/li>
&lt;li>不出意外, Postman就可以抓取到https的数据包了,位于左侧的 &lt;code>History&lt;/code> 栏下&lt;/li>
&lt;/ol>
&lt;p>官方操作传送门 &lt;a href="https://learning.postman.com/docs/sending-requests/capturing-request-data/capturing-http-requests/#using-postmans-proxy-example">https://learning.postman.com/docs/sending-requests/capturing-request-data/capturing-http-requests/#using-postmans-proxy-example&lt;/a>&lt;/p></description></item><item><title>SSH隧道连接局域网下的虚拟机</title><link>https://twbhub.com/post/tunnel_connect/</link><pubDate>Sun, 12 Jul 2020 18:18:13 +0800</pubDate><guid>https://twbhub.com/post/tunnel_connect/</guid><description>&lt;blockquote>
&lt;p>连接局域网下的虚拟机,在网上找到的做法通常是:在VMware配置端口转发
最近了解隧道技术,突发奇想:能不能使用SSH隧道连接局域网下的虚拟机呢?
在网上找到的相关资料不多,经过自己摸索,终于实现了
使用SSH隧道连接局域网下的虚拟机,主要有两种方式可以实现
1: 本地端口转发; 2: 动态端口转发&lt;/p>
&lt;/blockquote>
&lt;p>首先,假设网络图如下,A和B在同一局域网下,我们的目的是: 实现 A 连接到 C 的SSH服务
&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20200712191744.png" alt="">&lt;/p>
&lt;h2 id="方法一--本地端口转发">方法一 : 本地端口转发&lt;/h2>
&lt;blockquote>
&lt;p>大体思路: 在A下创建 &lt;code>A --&amp;gt; C&lt;/code> 的SSH隧道,就可以访问A下的指定端口,通过隧道转发,访问到C的22端口了
具体实现如下 :&lt;/p>
&lt;/blockquote>
&lt;h3 id="1b安装ssh服务">1#B安装SSH服务&lt;/h3>
&lt;blockquote>
&lt;p>参考文章 &lt;a href="https://www.cnblogs.com/sparkdev/p/10166061.html">https://www.cnblogs.com/sparkdev/p/10166061.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>这是非常关键的一步(作为小白,我刚开始就异想天开,直接就想通过A连接到C,直到多次尝试失败并且想通了)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>我的电脑 B 的系统是&lt;code>windows10 1909&lt;/code>,自带了&lt;code>OpenSSH Server&lt;/code>软件;如果版本是&lt;code>wondows10 1809&lt;/code>以下或&lt;code>wondows7&lt;/code>的同学,可以网上搜索windows怎么安装&lt;code>openSSH&lt;/code>服务&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>(1) Win10打开 设置(&lt;code>Win + I&lt;/code>) ==&amp;gt; 应用 ==&amp;gt; 应用和功能 ==&amp;gt; 可选功能 =&amp;gt; 添加功能 =&amp;gt; OpenSSH服务器(点击安装)&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20200712195856.png" alt="">&lt;/p>
&lt;p>(2) 打开 任务管理器(&lt;code>Shift + Ctrl + Esc&lt;/code>) ==&amp;gt; 任务 ==&amp;gt; 左下角点击&amp;quot;打开服务&amp;quot;; 找到两个OpenSSH服务,右键开启&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20200712200951.png" alt="">&lt;/p>
&lt;p>(3) 打开 控制面板 ==&amp;gt; 系统和安全 ==&amp;gt; &lt;code>Windows Defender&lt;/code> 防火墙 ==&amp;gt; 启用或关闭&lt;code>windows defender&lt;/code>防火墙;选择关闭防火墙; (或者在入站规则添加允许22端口)&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20200712202126.png" alt="">&lt;/p>
&lt;blockquote>
&lt;p>到此, B已经配置完成&lt;/p>
&lt;/blockquote>
&lt;h3 id="2a建立-a----c-的隧道">2#A建立 &lt;code>A --&amp;gt; C&lt;/code> 的隧道&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>本人使用的是&lt;code>PuTTY&lt;/code>的工具, 使用其他工具或&lt;code>PowerShell&lt;/code>也是可以的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>首先保证 C 关闭&lt;code>iptables&lt;/code>或&lt;code>nftables&lt;/code>防火墙 (或配置允许22端口)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过&amp;quot;中间人&amp;quot; B ; 在 A 电脑上使用&lt;code>PuTTY&lt;/code>建立起与 C 的SSH隧道 (本地端口转发)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>在 A 上配置(基于文章开头假设的网络图) :&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20200712204730.png" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>点击open,会出现登录,注意:这里登录的是 B 电脑,也就是要输入B的windows的用户名和密码;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>到这里,你已经建立起 &lt;code>A --&amp;gt; C&lt;/code> 的隧道了, 注意: 请不要关闭&lt;code>PuTTY&lt;/code>窗口, 否则隧道会被关闭&lt;/p>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;code>PuTTY&lt;/code>如上设置,相当于使用命令 &lt;code>ssh -CfNg -L 127.0.0.1:6666:192.168.2.2:22 192.168.1.107&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;h3 id="3a通过隧道连接-c-电脑">3#A通过隧道连接 C 电脑&lt;/h3>
&lt;ul>
&lt;li>终于到最后一步了, 很简单, 在 A 电脑开启新的&lt;code>PuTTY&lt;/code>窗口, 请求 A 本地的 刚才自定义的 6666端口就可以啦&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20200712210036.png" alt="">&lt;/p>
&lt;ul>
&lt;li>恭喜你, 成功通过SSH隧道连接到 C ;因为隧道是 &lt;code>A --&amp;gt; C&lt;/code> 的且加密的, B 不会监听到流量&lt;/li>
&lt;/ul>
&lt;h2 id="方法二--动态端口转发">方法二 : 动态端口转发&lt;/h2>
&lt;blockquote>
&lt;p>大体思路: 在A下创建 &lt;code>A --&amp;gt; B&lt;/code> 的SSH隧道,把 B 作为代理(Proxy), 就可以实现 : A 使用&lt;code>SOCKS5&lt;/code>协议通过 B 来访问到 C 的22端口
具体实现如下 :&lt;/p>
&lt;/blockquote>
&lt;h3 id="1b安装ssh服务-1">1#B安装SSH服务&lt;/h3>
&lt;p>(在 &lt;code>方法一&lt;/code> 中有具体实现, 略)&lt;/p>
&lt;h3 id="2a建立-a----b-的隧道">2#A建立 &lt;code>A --&amp;gt; B&lt;/code> 的隧道&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>本人使用的是&lt;code>PuTTY&lt;/code>的工具, 使用其他工具或PowerShell也是可以的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 A 电脑上使用&lt;code>PuTTY&lt;/code>建立起与 B 的SSH隧道 (动态端口转发)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>在 A 上配置(基于文章开头假设的网络图) :&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20200712215702.png" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>点击open,会出现登录,注意:这里登录的是 B 电脑,也就是要输入B的windows的用户名和密码;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>到这里,你已经建立起 &lt;code>A --&amp;gt; B&lt;/code> 的隧道了, 注意: 请不要关闭&lt;code>PuTTY&lt;/code>窗口, 否则隧道会被关闭&lt;/p>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;code>PuTTY&lt;/code>如上设置,相当于使用命令 &lt;code>ssh -CfNg -D 127.0.0.1:6666 192.168.1.107&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;h3 id="3a通过代理连接-c-电脑">3#A通过代理连接 C 电脑&lt;/h3>
&lt;ul>
&lt;li>终于到最后一步了, 很简单, 在 A 电脑上开启新的&lt;code>PuTTY&lt;/code>窗口, 设置 A 本地的 刚才自定义的 6666端口为代理端口, 请求 C 就可以啦&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20200712214629.png" alt="">&lt;/p>
&lt;h2 id="方法三--vmware配置端口转发">方法三 : VMware配置端口转发&lt;/h2>
&lt;blockquote>
&lt;p>这是一个比较普遍的做法, 在网上也容易找到相关文章
大体思路: 在&lt;code>VMware&lt;/code>上配置 监听父windows的端口X,把A端口转发到VMware下的虚拟机端口Y, 局域网的电脑只有访问windows的端口X就相当于访问虚拟机的端口Y啦, 是不是很容易
具体实现如下 :&lt;/p>
&lt;/blockquote>
&lt;h3 id="1b配置vmware">1#B配置VMware&lt;/h3>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20200712220946.png" alt="">&lt;/p>
&lt;h3 id="2b配置防火墙">2#B配置防火墙&lt;/h3>
&lt;ul>
&lt;li>打开 控制面板 ==&amp;gt; 系统和安全 ==&amp;gt; &lt;code>Windows Defender&lt;/code> 防火墙 ==&amp;gt; 启用或关闭&lt;code>windows defender&lt;/code>防火墙;选择关闭防火墙; (或者在 入站规则 添加允许 上一步自定义的6666端口)&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20200712202126.png" alt="">&lt;/p>
&lt;h3 id="3a通过-b-连接-c-电脑">3#A通过 B 连接 C 电脑&lt;/h3>
&lt;ul>
&lt;li>终于到最后一步了, 很简单, 在 A 电脑直接用&lt;code>PuTTY&lt;/code>请求 B 的 6666端口, 就可以登录 C 啦&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20200712222247.png" alt="">&lt;/p>
&lt;p>&lt;strong>&amp;hellip; 以上&lt;/strong>&lt;/p></description></item><item><title>VMware自定义虚拟网卡(添加网络)</title><link>https://twbhub.com/post/vmware_customize_network/</link><pubDate>Sun, 31 May 2020 14:07:40 +0800</pubDate><guid>https://twbhub.com/post/vmware_customize_network/</guid><description>&lt;blockquote>
&lt;p>我的VMware版本: 15.5.2&lt;/p>
&lt;/blockquote>
&lt;h2 id="一-创建虚拟网络">一 创建虚拟网络&lt;/h2>
&lt;ol>
&lt;li>VMware菜单==&amp;gt;编辑==&amp;gt;虚拟网络编辑器&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20200531154440.png" alt="">&lt;/p>
&lt;ol start="2">
&lt;li>(这一步可略过)移除所有默认的&amp;quot;网络&amp;quot;&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20200531154849.png" alt="">&lt;/p>
&lt;ol start="3">
&lt;li>点击&amp;quot;添加网络&amp;quot;, 选择&amp;quot;VMnet8&amp;quot;&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20200531155509.png" alt="">&lt;/p>
&lt;ol start="4">
&lt;li>
&lt;ul>
&lt;li>上方列表点击选择刚才添加的网络&amp;quot;VMnet8&amp;quot;;&lt;/li>
&lt;li>选择NAT模式;&lt;/li>
&lt;li>设置子网IP;一般设置&amp;quot;192.168.xxx.0&amp;quot;,我这设置为&amp;quot;192.168.2.0&amp;quot;&lt;/li>
&lt;li>设置子网掩码&amp;quot;255.255.255.0&amp;quot;,一般子网掩码固定;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20200531155727.png" alt="">&lt;/p>
&lt;ol start="5">
&lt;li>点击&amp;quot;NAT设置&amp;quot;;设置&amp;quot;网关IP&amp;quot;, 一般为&amp;quot;192.168.xxx.1&amp;quot;, 所以我这设置网关为&amp;quot;192.168.2.1&amp;quot;;点击&amp;quot;确定&amp;quot; (还有端口转发,一般用于局域网PC链接VMware里的虚拟机所使用)&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20200531160526.png" alt="">&lt;/p>
&lt;ol start="6">
&lt;li>点击&amp;quot;DHCP设置&amp;quot;; 这里可以设置网关分配给VMware下的虚拟机的起始IP和结束IP; 因为网关已经占用了192.168.xxx.1,所以这自定义起始IP可以为&amp;quot;192.168.xxx.2&amp;quot;, 结束IP为&amp;quot;192.168.xxx.254&amp;quot;, 点击&amp;quot;确认&amp;quot;, 回到上一层, 再次点击&amp;quot;确认&amp;quot;;&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20200531161155.png" alt="">&lt;/p>
&lt;h2 id="二-使用虚拟网络">二 使用虚拟网络&lt;/h2>
&lt;ol>
&lt;li>查看 控制面板==&amp;gt;网络和Internet==&amp;gt;网络和共享中心==&amp;gt;更改适配器设置; 可看到, 虚拟网卡已创建成功;&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20200531162022.png" alt="">&lt;/p>
&lt;ol start="2">
&lt;li>选择新添加的网卡;右键选择&amp;quot;属性&amp;quot;;双击&amp;quot;协议版本4&amp;quot;;设置IP;我这里设置了100;也可以设大一点,点击&amp;quot;确认&amp;quot;&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>如果缺少这一步,可能会出现宿主机SSH链接不上虚拟机的情况(或者出现需要长时间才连通,连上后,短时间内又断开的情况);原因可能是因为网卡的IP占用了网关IP&amp;quot;192.168.xxx.1&amp;quot;, 导致虚拟机的数据到不了在外一层的宿主机&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20200531163409.png" alt="">&lt;/p>
&lt;ol start="3">
&lt;li>虚拟网卡已创建成功,最后还要选择使用新创建的网卡;选择你要使用刚才新建网卡的虚拟机, 右键选择&amp;quot;设置&amp;quot;, &amp;ldquo;硬件&amp;rdquo;==&amp;gt;&amp;ldquo;网络适配器&amp;rdquo; ,右侧点击&amp;quot;自定义:特定虚拟网络&amp;quot;, 选择新建的&amp;quot;VMnet8(NAT 模式)&amp;quot;, 点击&amp;quot;确定&amp;quot;&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>这一步非常关键,我曾经缺少这一步,导致虚拟机连不上网&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20200531165342.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20200531165906.png" alt="">&lt;/p>
&lt;ol start="4">
&lt;li>到此,虚拟机应该就可以上网了,如果不行;请重启虚拟机的network; 或者VMware最右下角的&amp;quot;网络适配器&amp;quot;重新连接&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20200531171518.png" alt="">&lt;/p>
&lt;ol start="5">
&lt;li>同时还可以在虚拟机里设置固定的IP,IP地址要根据&amp;quot;起始IP&amp;quot;和结束&amp;quot;IP&amp;quot;设置; 例如,我在Centos8系统上, 设置了IP:&amp;ldquo;192.168.2.2&amp;rdquo;&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/twbworld/hosting@main/img/20200531171957.png" alt="">&lt;/p></description></item><item><title>keepalived高可用配置</title><link>https://twbhub.com/post/keepalived_ha/</link><pubDate>Sun, 02 Oct 2022 17:00:00 +0800</pubDate><guid>https://twbhub.com/post/keepalived_ha/</guid><description>&lt;blockquote>
&lt;p>&lt;code>keepalived&lt;/code>需要一个&lt;code>vip&lt;/code>;如果用的是云服务,那么得在后台申请一个高可用ip,才能实现&lt;code>vip飘移&lt;/code>;如果是自建服务器,那么一台服务器得使用两个网卡;只是为了测试,那么使用&lt;code>docker容器&lt;/code>模拟集群是最合适的了&lt;/p>
&lt;/blockquote>
&lt;h2 id="nginxkeepalived">Nginx+keepalived&lt;/h2>
&lt;p>&lt;code>Nginx&lt;/code>一主(172.1.1.11)一备(172.1.1.12),那么备服务器也太浪费了,所以除了&lt;code>keepalived高可用&lt;/code>还涉及到四层网络的负载均衡;一般主备都需要配置&lt;code>haproxy&lt;/code>,它是Linux内核自带的;为了方便,&lt;code>Nginx&lt;/code>的&lt;code>stream模块&lt;/code>也能实现四层负载均衡&lt;/p>
&lt;blockquote>
&lt;p>一备一主&lt;code>Nginx&lt;/code>都需要类似配置 :&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">stream &lt;span style="color:#f92672">{&lt;/span>
upstream web_server &lt;span style="color:#f92672">{&lt;/span>
server 172.1.1.11:8080 weight&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> max_fails&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span> fail_timeout&lt;span style="color:#f92672">=&lt;/span>10s;
server 172.1.1.12:8080 weight&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> max_fails&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span> fail_timeout&lt;span style="color:#f92672">=&lt;/span>10s;
&lt;span style="color:#f92672">}&lt;/span>
server &lt;span style="color:#f92672">{&lt;/span>
listen &lt;span style="color:#ae81ff">80&lt;/span> reuseport;
proxy_pass web_server;
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
http &lt;span style="color:#f92672">{&lt;/span>
server &lt;span style="color:#f92672">{&lt;/span>
listen 172.1.1.11:8080; &lt;span style="color:#75715e">#使用本机ip;stream和http不能监听相同端口,所以另用端口,除非指定不同的ip:port&lt;/span>
&lt;span style="color:#75715e"># ...&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>一备一主&lt;code>keepalived&lt;/code>都需要相同配置&lt;code>/etc/keepalived/keepalived.conf&lt;/code> :&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">global_defs &lt;span style="color:#f92672">{&lt;/span>
router_id LVS_DEVEL
&lt;span style="color:#f92672">}&lt;/span>
vrrp_script check_nginx &lt;span style="color:#f92672">{&lt;/span>
script &lt;span style="color:#e6db74">&amp;#34;/etc/keepalived/check_nginx.sh&amp;#34;&lt;/span>
interval &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#75715e">#检测时间&lt;/span>
fall &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#75715e">#检测失败次数&lt;/span>
rise &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#75715e">#检测成功次数&lt;/span>
weight -20 &lt;span style="color:#75715e">#sh脚本执行了&amp;#34;exit 1&amp;#34;后的权重变化&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
vrrp_instance VI_1 &lt;span style="color:#f92672">{&lt;/span>
state BACKUP
interface eth0 &lt;span style="color:#75715e">#网卡&lt;/span>
virtual_router_id &lt;span style="color:#ae81ff">70&lt;/span> &lt;span style="color:#75715e">#组唯一id&lt;/span>
priority &lt;span style="color:#ae81ff">100&lt;/span> &lt;span style="color:#75715e">#权重&lt;/span>
&lt;span style="color:#75715e">#nopreempt #非抢占模式,对BACKUP生效,宕机恢复后,不会抢占vip&lt;/span>
advert_int &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#75715e">#MASTER与BACKUP之间检查的时间&lt;/span>
virtual_ipaddress &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">#飘移的vip&lt;/span>
172.1.1.100/24
&lt;span style="color:#f92672">}&lt;/span>
track_script &lt;span style="color:#f92672">{&lt;/span>
check_nginx
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>一备一主都需要添加 检测nginx状态 的脚本&lt;code>/etc/keepalived/check_nginx.sh&lt;/code> :&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;span style="color:#75715e">&lt;/span>A&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>ps -C nginx --no-header | wc -l&lt;span style="color:#e6db74">`&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> $A -eq &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">]&lt;/span>;&lt;span style="color:#66d9ef">then&lt;/span>
&lt;span style="color:#75715e">#/usr/sbin/nginx #重启nginx&lt;/span>
sleep &lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> $A -eq &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">]&lt;/span>;&lt;span style="color:#66d9ef">then&lt;/span>
&lt;span style="color:#75715e">#pkill keepalived&lt;/span>
exit &lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;span style="color:#66d9ef">fi&lt;/span>
exit &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="rediskeepalived">Redis+keepalived&lt;/h2>
&lt;p>Redis不同于Nginx,Redis需要实现多个服务器的redis数据同步,所以配置分为三步:&lt;/p>
&lt;ol>
&lt;li>配置Redis集群主从库复制&lt;/li>
&lt;li>配置Redis的集群哨兵模式,用于检测Redis状态,宕机及时切换主数据库,数据恢复&lt;/li>
&lt;li>使用&lt;code>Nginx&lt;/code>的&lt;code>stream模块&lt;/code>实现读写分离和读的负载均衡&lt;/li>
&lt;li>配置keepalived,负责Redis切换主库后的飘移vip&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>添加配置到从库的&lt;code>redis.conf&lt;/code>,实现复制主库(172.1.1.11)的数据&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">replicaof 172.1.1.11 &lt;span style="color:#ae81ff">6379&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>一备一主的哨兵都需要相同配置&lt;code>sentinel.conf&lt;/code> :&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">port &lt;span style="color:#ae81ff">26379&lt;/span>
daemonize yes
protected-mode no
pidfile &lt;span style="color:#e6db74">&amp;#34;/var/run/sentinel/redis-sentinel.pid&amp;#34;&lt;/span>
logfile &lt;span style="color:#e6db74">&amp;#34;/var/log/redis/redis-sentinel.log&amp;#34;&lt;/span>
dir &lt;span style="color:#e6db74">&amp;#34;/tmp&amp;#34;&lt;/span>
sentinel myid db1f6c96877303e3aa393481d00359abae6b2e7d
sentinel deny-scripts-reconfig yes
sentinel monitor mymaster 172.1.1.11 &lt;span style="color:#ae81ff">6379&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#75715e">#查看主从状态&lt;/span>
redis-cli -p &lt;span style="color:#ae81ff">26379&lt;/span>
&amp;gt;sentinel master mymaster
&amp;gt;SENTINEL get-master-addr-by-name mymaster
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>&lt;code>Nginx&lt;/code>配置为Redis中间代理实现读写分离和负载均衡(读和写不同端口),一备一主&lt;code>Nginx&lt;/code>都需要类似配置,可添加到&lt;a href="#Nginx&amp;#43;keepalived">上文&lt;/a>的同一份配置文件 :&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">stream &lt;span style="color:#f92672">{&lt;/span>
upstream redis_r &lt;span style="color:#f92672">{&lt;/span>
server 172.1.1.11:6379 weight&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> max_fails&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span> fail_timeout&lt;span style="color:#f92672">=&lt;/span>10s;
server 172.1.1.12:6379 weight&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> max_fails&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span> fail_timeout&lt;span style="color:#f92672">=&lt;/span>10s;
&lt;span style="color:#f92672">}&lt;/span>
upstream redis_w &lt;span style="color:#f92672">{&lt;/span>
server 172.1.1.101:6379 weight&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> max_fails&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span> fail_timeout&lt;span style="color:#f92672">=&lt;/span>10s; &lt;span style="color:#75715e">#keepalived偏移vip&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">#redis读&lt;/span>
server &lt;span style="color:#f92672">{&lt;/span>
listen &lt;span style="color:#ae81ff">6389&lt;/span> reuseport;
proxy_pass redis_r;
proxy_connect_timeout 3s;
proxy_timeout 60s;
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">#redis写&lt;/span>
server &lt;span style="color:#f92672">{&lt;/span>
listen &lt;span style="color:#ae81ff">6399&lt;/span> reuseport;
proxy_pass redis_w;
proxy_connect_timeout 3s;
proxy_timeout 60s;
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
http &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e"># ...&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>一备一主&lt;code>keepalived&lt;/code>都需要相同配置,添加到&lt;a href="#Nginx&amp;#43;keepalived">上文&lt;/a>的同一份配置文件&lt;code>/etc/keepalived/keepalived.conf&lt;/code> :&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">vrrp_script check_redis &lt;span style="color:#f92672">{&lt;/span>
script &lt;span style="color:#e6db74">&amp;#34;/etc/keepalived/check_redis.sh&amp;#34;&lt;/span>
interval &lt;span style="color:#ae81ff">2&lt;/span>
weight -30
&lt;span style="color:#f92672">}&lt;/span>
vrrp_instance VI_2 &lt;span style="color:#f92672">{&lt;/span>
state BACKUP
interface eth0
virtual_router_id &lt;span style="color:#ae81ff">80&lt;/span>
priority &lt;span style="color:#ae81ff">100&lt;/span>
advert_int &lt;span style="color:#ae81ff">1&lt;/span>
virtual_ipaddress &lt;span style="color:#f92672">{&lt;/span>
172.1.1.101/24
&lt;span style="color:#f92672">}&lt;/span>
track_script &lt;span style="color:#f92672">{&lt;/span>
check_redis
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>一备一主都需要添加 检测Redis状态 的脚本&lt;code>/etc/keepalived/check_redis.sh&lt;/code> :&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#检测是否master主库(redis-sentinel推举出主库)&lt;/span>
A&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>redis-cli info|grep role:master&lt;span style="color:#e6db74">`&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> -z $A &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
sleep &lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> -z $A &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
exit &lt;span style="color:#ae81ff">1&lt;/span>
&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;span style="color:#66d9ef">fi&lt;/span>
exit &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>