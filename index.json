[{"authors":["admin"],"categories":null,"content":" PHP小白 码农 韭菜 社畜  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":1613396406,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://twbworld.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"PHP小白 码农 韭菜 社畜","tags":null,"title":"忐忑","type":"authors"},{"authors":["忐忑"],"categories":null,"content":"前文 关于发布Docker镜像到仓库, 思路有不少, 比如:\n 本地生成Docker镜像后, 使用 docker login 登录, 然后再 docker push 发布到仓库(Docker Hub等) Docker仓库平台(Docker Hub等) 关联 Github项目 , git push 后, 仓库平台会获取 Github项目 下的 Dockerfile 等相关文件, 自动构建Docker镜像  本文要讲的是第3种思路, 利用 Github Actions 自动化构建和发布, 与 Github 更高度的结合\n仓库平台区别 Docker Hub 再熟悉不过, 它是Docker的官方平台, 不作多介绍\n对于 Github 下却有两个发布Docker镜像的平台, ghcr.io 和 docker.pkg.github.com\n区别1 前者发布的镜像在 用户 之下, 地址格式 : https://ghcr.io/[用户名]/[镜像名]\n后者发布的镜像在 项目 之下, 地址格式 : https://docker.pkg.github.com/[用户名]/[项目名]/[镜像名]\n区别2 前者下的镜像可选择公开, 任何人都可 docker pull\n后者却只能用户授权才能 docker pull\n本文重点讲如何发布到 ghcr.io\n发布到ghcr.io 步骤一 想要在 GitHub 使用 ghcr.io , 首先要 启用改进的容器支持\n步骤二 需要生成 GitHub账号 的 Token ; 用于 GitHub-Actions 有权限操作 GitHub账号 下的项目 ;\n登录 GitHub , 右上角点击用户头像, 找到 settings \u0026gt; Developer settings \u0026gt; Personal access tokens , 点击 Generate new token , 传送门直达 , 如图 : 接着, 设置 Token 的权限, 选择 write:packages (这样,连同 repo 都一起勾选了), 如图 : 最后生成了一个 Token , 一定要记录下来, 下一步要用到\n步骤三 把生成的 Token 添加到您的GitHub项目 secrets 下 ; 找到项目下 Setting \u0026gt; secrets , 右上角点击 New repository secret , 如图 如图\nName 值填写 PACKAGES_TOKEN (可自定义, 但下一步用到的 secrets.PACKAGES_TOKEN 同步要改)\nValue 值填写 上一步获得的 Token , 最后点击 Add secret ;\nGitHub-Actions 就可通过secrets.PACKAGES_TOKEN 获取 Token , 用于发布镜像到 ghcr.io 了 步骤三 如何使用 GitHub-Actions 在此不过多简释, 直接贴出代码 :\nname: ci on: workflow_dispatch: #github页面手动触发 push: tags: - \u0026#34;v*.*\u0026#34; env: IMAGE_NAME: test #这是您的镜像名 jobs: get-tags: runs-on: ubuntu-20.04 env: TZ: Asia/Shanghai outputs: tags: ${{ steps.set-output-id.outputs.tags }} steps: - uses: actions/checkout@v2 - name: set-output id: set-output-id run: |VERSION=edge if [[ $GITHUB_REF == refs/tags/* ]]; then VERSION=${GITHUB_REF#refs/tags/v} fi echo ::set-output name=tags::${VERSION} push-ghcr: runs-on: ubuntu-20.04 env: TZ: Asia/Shanghai REGISTRY: ghcr.io steps: - uses: actions/checkout@v2 - name: Login uses: docker/login-action@v1 with: registry: ${{ env.REGISTRY }} username: ${{ github.repository_owner }} password: ${{ secrets.PACKAGES_TOKEN }} - name: Build \u0026amp;\u0026amp; Push uses: docker/build-push-action@v2 with: context: . file: ./Dockerfile push: true tags: |${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ needs.get-tags.outputs.tags }} ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:latest  借鉴代码\n 如图, GitHub-Actions 运行成功后, 在用户首页下的 Packages 模块下, 新增了一个 Packages 但是, 可看到 Private 标签, 也就是说, 这个Docker镜像默认不公开的 ; 如需要公开, 请往下看\n步骤四 公开 Packages 下的Docker镜像 ; 进入需要公开的镜像后, 点击右上角 Package Settings , 进入配置页面 拉到低, 点击 Change visibility , 就可设置为公开 ;\n在任何地方, 都可以下载镜像: docker pull ghcr.io/[用户名]/[镜像名]:[标签] 步骤五 虽然这个镜像是通过您的GitHub项目发布的, 但默认是不会关联到对应GitHub项目的 ;\n在上文 仓库平台区别 已经知道, ghcr.io 下的镜像是对应账号, 而不是 项目 的 ;\n如果需要将该镜像关联到对应项目, 也很简单 :\n如图 , 进入该镜像的页面, 在页面下就可以看到 Connect Repository 按钮, 点击关联对应的项目 ; 项目下的 README.md 也会加载进来 来到对应的GitHub项目下, 也可以看到关联的Docker镜像, 如图 : 发布到其他仓库 给出全部代码, 同时发布到 Docker Hub / ghcr.io / docker.pkg.github.com\nname: ci on: workflow_dispatch: #github页面手动触发 push: tags: - \u0026#34;v*.*\u0026#34; env: IMAGE_NAME: test #这是您的镜像名 jobs: get-tags: runs-on: ubuntu-20.04 env: TZ: Asia/Shanghai outputs: tags: ${{ steps.set-output-id.outputs.tags }} steps: - uses: actions/checkout@v2 - name: set-output id: set-output-id run: |VERSION=edge if [[ $GITHUB_REF == refs/tags/* ]]; then VERSION=${GITHUB_REF#refs/tags/v} fi echo ::set-output name=tags::${VERSION} push-ghcr: needs: get-tags runs-on: ubuntu-20.04 env: TZ: Asia/Shanghai REGISTRY: ghcr.io steps: - uses: actions/checkout@v2 - name: Login uses: docker/login-action@v1 with: registry: ${{ env.REGISTRY }} username: ${{ github.repository_owner }} password: ${{ secrets.PACKAGES_TOKEN }} - name: Build \u0026amp;\u0026amp; Push uses: docker/build-push-action@v2 with: context: . file: ./Dockerfile push: true tags: |${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ needs.get-tags.outputs.tags }} ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:latest push-docker-hub: needs: get-tags runs-on: ubuntu-20.04 env: TZ: Asia/Shanghai steps: - uses: actions/checkout@v2 - name: Login uses: docker/login-action@v1 with: username: ${{ secrets.DOCKERHUB_USERNAME }} password: ${{ secrets.DOCKERHUB_TOKEN }} - name: Build \u0026amp;\u0026amp; Push uses: docker/build-push-action@v2 with: context: . file: ./Dockerfile push: true tags: |${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ needs.get-tags.outputs.tags }} ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:latest push-docker-pkg-github: needs: get-tags runs-on: ubuntu-20.04 env: REGISTRY: docker.pkg.github.com TZ: Asia/Shanghai steps: - uses: actions/checkout@v2 - name: Login uses: docker/login-action@v1 with: registry: ${{ env.REGISTRY }} username: ${{ github.actor }} password: ${{ secrets.PACKAGES_TOKEN }} - name: Build \u0026amp;\u0026amp; Push uses: docker/build-push-action@v2 with: context: . file: ./Dockerfile push: true tags: |${{ env.REGISTRY }}/${{ github.repository }}/${{ env.IMAGE_NAME }}:${{ needs.get-tags.outputs.tags }} ${{ env.REGISTRY }}/${{ github.repository }}/${{ env.IMAGE_NAME }}:latest - name: Delete Package uses: actions/delete-package-versions@v1 with: package-name: ${{ env.IMAGE_NAME }} num-old-versions-to-delete: 1 #删除最旧的一个包  GitHub-Actions 真香 !\n ","date":1615615200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1615666223,"objectID":"3886dc2914e9208bb728de5c9140621f","permalink":"https://twbworld.github.io/post/github-actions_publish_images/","publishdate":"2021-03-13T14:00:00+08:00","relpermalink":"/post/github-actions_publish_images/","section":"post","summary":"使用GitHub Actions实现对docker包的自动化构建及发布","tags":["Github"],"title":"使用Github Actions发布docker镜像到仓库","type":"post"},{"authors":["忐忑"],"categories":null,"content":"问题  刚刚接触github actions实现CI/CD, 遇到了一个yml文件触发失败的问题\n yml文件配置如下 :\nname: ci-test on: pull_request: branches: - dev jobs: ssh-login: runs-on: ubuntu-latest steps: - uses: appleboy/ssh-action@master with: host: ${{ secrets.HOST }} username: ${{ secrets.USERNAME }} key: ${{ secrets.KEY }} port: ${{ secrets.PORT }} script: | ls ./ 当使用 git pull 时, 却没有触发该yml文件(在github项目的Actions的选项卡下不存在任务)\n但是,当把触发条件 pull_request 改成 push , 再push到Github 却意外的成功了触发了Actions\n解决 最后多次尝试,才发现问题 :\npull_request 触发条件只能在默认分支上使用, 也就是说我的配置项 branches 下的 dev 不是项目的默认分支, 所以触发Actions失败, 除此之外还有 workflow_run | issue\n 都怪没认真看文档\n 另外再做个笔记 :\n如果 workflows 目录下有多个yml, GitHub-Actions默认是并行触发的, 如果想实现按顺序触发, 请使用 workflow_run\n GitHub-Actions 真香 !\n ","date":1611399600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1615666223,"objectID":"33c172a2c78071551e09fb57e3b143b3","permalink":"https://twbworld.github.io/post/github_actions_invalid/","publishdate":"2021-01-23T19:00:00+08:00","relpermalink":"/post/github_actions_invalid/","section":"post","summary":"刚刚接触GitHub Actions实现CI/CD, 遇到了一个yml文件触发失败的问题","tags":["Github"],"title":"GitHub Actions无法触发","type":"post"},{"authors":["忐忑"],"categories":null,"content":"扩展知识 双系统制作  https://blog.csdn.net/mengxiangjia_linxi/article/details/78965103\n  电脑已有 Windows系统 的前提下,用 UltraISO 把 centos系统 刻入U盘 启动系统U盘(新机用 uefi启动 ),在系统选择页面,按下 tab健 修改启动项,把 LABEL=CentOS\\x207\\x20x86_64 改为 /dev/sdb4 (不一定是 sdb4 ,可能是 sda4 , sdc4 等等,具体百度) 安装系统界面,选择硬盘,自动分配分区得以回收空间 重做 PE启动盘 ,启动盘用 NTBOOT 软件做 双系统引导修复  常用 命令\u0026amp;\u0026amp;快捷键 Linux    命令 描述     .. 上一级目录   cd - 上一次目录   ctrl+C 强制中断   ctrl+U 清除输入命令   !v 执行上一条以\u0026rsquo;v\u0026rsquo;开头的命令   ll ls -l 缩写   2\u0026gt;\u0026amp;1 输出错误   |grep 过滤结果   ctrl+a/e 命令最前/后   clear 清屏(或ctrl+L)   pwd 当前目录   cat 查看文件内容   mkdir/mv/cp/rm 文件名操作   \\cp 当有同名文件,不需要输\u0026quot;Y\u0026quot;即可覆盖   useradd 创建新用户   which 查找命令   chown 设置文件拥有者   chmod 设置u/g/o权限   setfacl -R -m u:apache:rwx /var 设置单独用户的权限(getfacl查看)   chattr 设置文件属性,如设置成禁止删除文件   ps -ef(ps aux) 查看所有进程   pstree -p 查看进程树   pkill httpd 关闭某进程(或killall)   uptime 计算机负载   top 实时负载(可安装htop加强版)   df -h 磁盘占用   du -h \u0026ndash;max-depth=0 * (du -sh *) 目录下各个文件大小   pkill -kill -t pts/1 强退指定用户   who 在线用户(或缩写w)   last 用户登录历史记录   id 查看用户所在的组   lsof -i:80 查看端口   netstat -antup | grep nginx 查看进程或端口等   man 命令帮助(可安装中文软件)   curl ifconfig.me 查看公网ip   rpm -qa|grep 查看应用程序   pkill -HUP nginx 系统级别重载配置文件   systemctl status nginx.service 查看状态(或service nginx status)   chkconfig iptables off 永久关闭防火墙   chkconfig iptables on 永久关闭后重启   ln 软连接   nohup \u0026lt;shell\u0026gt; 在后台运行shell命令   tree -LNFC 2 tree软件常用命令   tar -xaf 识别压缩文件类型,进行解压(-caf)   unzip -O cp936 zip文件解压避免乱码   find / -type f -name \u0026ldquo;*.txt\u0026rdquo; | xargs grep \u0026ldquo;hello\u0026rdquo; 查找文件内容   cat \u0026lt;filename\u0026gt; | openssl dgst -sha256 -binary | openssl base64 -A 计算文件sha256校验值(css校验方法:\u0026lt;link href=\u0026quot;filename.css\u0026quot; integrity=\u0026quot;sha256-h20CPZ0QyXlBuAw7A+KluUYx/3pK+c7lYEpqLTlxjYQ=\u0026quot;\u0026gt;)   sha256sum filename 计算文件md5校验值   docker container list -aq |xargs docker container rm docker清理容器(同样效果 docker container prune)   docker volume ls -q |xargs docker volume rm docker清理卷(同样效果 docker volume prune)    Git    命令 描述     git diff \u0026lt;file\u0026gt; 工作区版本库对比   git diff \u0026lt;commit-id\u0026gt; \u0026lt;commit-id\u0026gt; --stat 比较两个版本变化了的文件   git commit --amend 修改已commit的备注   git commit –am \u0026lt;备注\u0026gt; 直接跳过add命令   git reset --hard HEAD 还原最新版   git reset --hard \u0026lt;commit-id\u0026gt; 还原指定版   git reset HEAD \u0026lt;file\u0026gt; 放弃暂存区的修改   git checkout -- \u0026lt;file\u0026gt; 放弃工作区的修改   git checkout . \u0026amp;\u0026amp; git clean -df 清除所有新增的文件目录   git checkout –b \u0026lt;name\u0026gt; 创建并切换分支   git branch -D \u0026lt;name\u0026gt; 丢弃未合并的分支   git branch -r -d origin/\u0026lt;name\u0026gt; \u0026amp;\u0026amp; git push origin :\u0026lt;name\u0026gt; 删除远程分支   git mergetool 解决冲突的合并工具   git tag -a \u0026lt;name\u0026gt; -m \u0026lt;备注\u0026gt; \u0026lt;commit-id\u0026gt; 创建并指定标签信息   git show \u0026lt;name\u0026gt; 查看标签信息   git stash 保存当前工作现场   git stash pop 恢复并删除工作现场   git stash list 查看工作现场   git stash apply \u0026lt;stash@{0}\u0026gt; 恢复工作现场   git stash drop \u0026lt;stash@{0}\u0026gt; 删除工作现场   git reflog \u0026lt;file\u0026gt; 命令历史   git revert \u0026lt;commit-id\u0026gt; 撤销某个版本   git cherry-pick \u0026lt;commit-id\u0026gt; 提取某个分支的某个版本到当前分支   git check-ignore -v \u0026lt;file\u0026gt; 检查哪个规则忽略了文件   git rm -rf --cached . \u0026amp;\u0026amp; git add -A 清徐缓存,用于更新gitignore   git submodule add \u0026lt;远程项目地址\u0026gt; \u0026lt;路径\u0026gt; 添加子模块   git submodule update --init --recursive 下载所有子模块   git submodule update --remote 更新所有子模块   git worktree add ../folder master 关联某分支到目录   git remote show origin 详细的远程分支的信息   git log --oneline --graph --decorate --all -9 可视化显示版本树   git config --global alias.lg \u0026quot;log --color --graph --all --oneline --decorate --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset' --abbrev-commit\u0026quot; 可视化显示版本树配置别名   git config --global core.filemode false 关闭git对文件权限的监视   git config --global core.quotepath false 正常显示中文文件名   git config --global color.ui true 彩色显示    Vim    命令 效果     !\u0026lt;shell\u0026gt; 执行系统命令   u 后退   Ctrl + r 前进   i/I/a/A/o/O 前/行首/后/行尾/上行/下行 插入   b/e/^/$/H/M/L/gg/G 移动光标到 跳前/跳后/行首/行尾/窗头/窗中/窗尾/头部/尾部   Ctrl + b/f/d/u 翻一页/半页   D 删除到行尾   dG 向下删除   dd 删除当前行   yy 复制   p 粘贴   ddp 与下行互换位置   yyp 新增一行   ggvG 全选   set number 显示行数   vim +X \u0026lt;filename\u0026gt; 文件加密   :\u0026lt;number\u0026gt; 跳到指定行   /\u0026lt;name\u0026gt; 搜索(按 n/N 向 下/上 查找)    Sublime    快捷键 描述     Ctrl+Shift+L 所有选中的行,在行后后出现光标   Ctrl+Shift+M 选中括号里的内容   Ctrl+M 光标在括号前后跳   Ctrl+Shift+[ / ] 隐藏/显示 内容   Ctrl+J 多行成一行   Ctrl+KK 删除行后的内容   Ctrl+K+U / L 选中的内容 大写/小写   Ctrl+F2 标记行   F6 检错   Alt+. 补充标签   Alt+数字 跳转tag   shift+pgup 向下选择    Vimium    快捷键 描述     o 搜索   j/k 滚动   gg/G 头/底部   d/u 翻页   f 打开连接   x/X 关闭/恢复标签页   J/K 上/下一个标签页   yy 复制链接   H/L 后退/前进记录   p 刷新   t 新建标签页    chrome    快捷键 描述     Ctrl+0 恢复100%   Ctrl+j 下载页   Ctrl+Shift+Delete 清除数据   Ctrl+u html源码   chrome://net-internals/#dns 清除DNS    windows    快捷键 描述     Win+← 小化   win+v 粘贴板   Win+i 设置页   Shift+Ctrl+Esc 任务管理器   Alt+F4 关机   Alt+1/Enter/双击 查看文件属性   Alt+↑ 上一级目录   Alt+2(Shift+Ctrl+n) 新建文件夹   右击+v+d 隐藏图标(等等操作)   ctrl+win+D 新建桌面   ctrl+win+← 返回桌面(老板键)    Linux  端口号\u0026lt;1024为系统预留端口 uid \u0026lt; 500 为系统用户 非root用户不能监听\u0026lt;1024的端口(所以一般root启动nginx) nobody为Linux非登录用户,其作为nginx运行用户可保证安全 Linux的共享:NFS协议 windows与linux共享:SMB协议(Samba软件)     权限 符号 描述     可执行 x 可以进入该目录,无法读取该目录中的内容   可执行可读 xr 可以进入该目录并读取该目录中的内容,不能创建文件   可执行可写 xw 可以创建文件但是不能读取    ubuntu环境安装流程 :\n.bashrc命令别名 ufw防火墙关闭 静态ip ali源 vim安装及.vimrc解决乱码 ssh安装及配置 samba安装及配置;用户:root;密码:root; 传项目文件 python升级 net-tools安装 htop安装 git安装及配置 tig安装 tree安装 screen安装 docker安装 docker-compose安装 golang安装 hugo安装 node安装 php安装 mysql安装 Git   初始配置Git\n  设置本地用户和邮箱 git config --global user.name \u0026lt;your_name\u0026gt; \u0026amp;\u0026amp; git config --global user.email \u0026lt;your_email\u0026gt; 本地生成公钥 ssh-keygen -t rsa -C \u0026lt;your_email\u0026gt; 找到公钥,复制到github账号(即添加过公钥的用户才被允许管理github项目) 测试公钥 ssh -T git@github.com 到github创建项目 本地创建项目并初始化 git init 关联远程库和本地 git remote add \u0026lt;自定义远程仓库名,如origin\u0026gt; \u0026lt;远程项目地址\u0026gt; 可查看本地关联的所有仓库主机 git remote -v 或者 git remote show origin 把项目添加到缓存区 git add . 和 git commit –m \u0026lt;备注\u0026gt; 提交项目到origin仓库的master分支 git push origin master (添加\u0026quot;--tags\u0026quot;可同时上传tag)     git hook :\n  第三方仓库git hook 服务器部署git裸仓库 http://kongfangyu.com/2016/02/12/git-deploy     备注规范 :\n  feat: 新功能 fix: 修复 bug perf: 提升性能的改动 refactor: bug 修复和添加新功能之外的代码改动,重构大改动 chore: 其他修改,构建过程或辅助工具和库（如文档生成）的更改 docs: 文档变动 style: 格式调整，对代码实际运行没有改动，例如添加空行、格式化等 test: 添加或修正测试代码 ci: 持续集成相关文件修改 release: 发布新版本 revert: 恢复上一次提交     编译安装 # 配置 ./configure --prefix=/usr/local/nginx # 清除编译文件 make clean # 编译 make # 安装 make install # 软连接 ln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx # 开机自启 vim /etc/init.d/nginx \u0026amp;\u0026amp; chmod a+x /etc/init.d/nginx # 加入chkconfig管理列表 chkconfig --add /etc/init.d/nginx chkconfig nginx on systemctl status nginx.service CentOS指定版本安装 1. 到官网找到对应版本的rpm包,如:http://nginx.org/packages 2. 下载rpm包:wget http://nginx.org/packages/.../xxx.rpm 3. 安装:yum install -y xxx.rpm 4. /etc/rc.d/rc.local是系统启动后执行的文件,可在里添加自启的命令(但不推荐用这方式) 5. /etc/profile是系统变量的文件  网络   TCP :需要三次握手,建立了 TCP 虚拟通道,之后, TCP 运输 HTTP流\n  SSL : 位于 TCP 与 HTTP 之间,作为 HTTP 的安全供应商，全权负责 HTTP 的安全加密工作。\n  TLS : 在 SSL3.0 版本的基础上，重新设计并命名了这个协议，其全新的名字为 TLS ,形成: TCP连接时间 + TLS 连接时间 + HTTP交易时间\n  HTTPS : 通常将 TLS 安全保护的 HTTP 通信，称之为 HTTPS ，以区别于没有 TLS 安全防护的 HTTP 明文通信。\n  HTTP/2 : 第一次页面与第二次页面都是同一个网站服务器,重用第一个页面 TCP 连接\n  QUIC : http/2 去掉 TCP ,改用不需要连接的 UDP ,形成: UDP / QUIC ,第一次 2.5RTT ,完成 QUIC 交易的连接的 Session ID 会缓存在浏览器内存里,第二次,使用 Session ID ,重连 TLS 连接是一个 0 RTT 事件\n  HTTP/3 : 把 QUIC 与 HTTP 分离,形成: UDP / QUIC / HTTP\n  使用 IPv4 进行路由，使用 TCP 进行连接层面的流量控制，使用 SSL/TLS 协议实现传输安全，使用 DNS 进行域名解析，使用 HTTP 进行应用数据的传输。\n  IP 是网络层\n  TCP 是传输层\n  网络层 ARP : 保存 IP 与 mac 地址的映射列表,没有则会广播\n  TCP/IP 连接 + http 传输 \u0026ndash;\u0026gt; 网卡 \u0026ndash;\u0026gt; 内核(通过资源包的四元组信息,信息的其中之二是访问的 IP+端口 ) \u0026ndash;\u0026gt; socket(它是文件系统,是资源,储存着端对端的四元组信息,被进程使用) \u0026ndash;\u0026gt; 进程\n  socket 是网络与进程的中介\n  隧道  https://www.zhihu.com/question/39382183\n  隧道是一种技术,有 SSH隧道 和 http隧道 和 UDP隧道(p2p) 隧道的中间服务器是不参与流量分析的,只用来传输流量,只是用于简单的过度 代理是可以参与流量的处理的,比如 http代理 但 http代理 不能传输 https流量 ,因为 https 是端对端的加密,没有中间人 为了解决不能代理 https流量 , http隧道 配合 http 的 CONNECT报文 解决了这个问题; SOCKS5 方式可以代替 CONNECT报文 的方法, CONNECT报文 只能用于 http流量 ,而 SOCKS5 可以传输任意协议,如 https 或 ftp 大致原理: 本地---(1)---\u0026gt;代理---(2)---\u0026gt;服务器; 本地与代理建立动态端口隧道,过程(1) 使用 SOCKS5 或 http 的 CONNECT报文(包裹着https流量) , 过程 (2) 使用 https;   https://www.zsythink.net/archives/2450\n   动态转发(科学上网)\n# socks5代理的建立 ssh -N -f -D 127.0.0.1:6666 root@121.199.63.39 # 原理:本地(127.0.0.1:6666)与代理(121.199.63.39)服务器建立隧道后,本地(127.0.0.1)使用socks5协议在外层加密https协议,通过本地代理端口(6666)-(隧道)-代理(121.199.63.39)-https访问服务端(https://www.google.com) curl -x socks5://127.0.0.1:6666 https://www.google.com #http为例 ssh -o ProxyCommand=\u0026#34;nc -X 5 -x 127.0.0.1:6666 %h %p\u0026#34; https://www.google.com #ssh为例,参数-X默认socks5   本地转发\nssh -N -f -L 192.168.2.2:6666:121.199.63.39:22 root@121.199.63.39   远程转发\nssh -N -f -R 121.199.63.39:6666:127.0.0.1:22 root@121.199.63.39   通过 121.199.63.39 的 22 端口,登录 121.199.63.39localhost 的 6666 端口\nssh -J root@121.199.63.39:22 -p6666 localhost   Nftables 防火墙配置例子 :\n# my.nft table inet filter { chain input { type filter hook input priority 0; policy drop; ct state established,related accept iif \u0026#34;lo\u0026#34; accept comment \u0026#34;一律接受本地环回\u0026#34; ct state invalid drop ip protocol icmp icmp type echo-request ct state new accept ip protocol udp ct state new jump UDP ip protocol tcp tcp flags \u0026amp; (fin | syn | rst | ack) == syn ct state new jump TCP ip protocol udp reject ip protocol tcp reject with tcp reset meta nfproto ipv4 counter packets 0 bytes 0 reject with icmp type prot-unreachable } chain forward { type filter hook forward priority 0; policy drop; } chain output { type filter hook output priority 0; policy accept; } chain TCP { tcp dport ssh ct state new limit rate 15/minute accept comment \u0026#34;避免对SSH施加暴力\u0026#34; tcp dport { http, https, mysql } accept comment \u0026#34;80,443,3306\u0026#34; tcp dport domain accept comment \u0026#34;DNS:53\u0026#34; tcp dport { netbios-ns, netbios-dgm, netbios-ssn, microsoft-ds } accept comment \u0026#34;Samba:137,138,139,445\u0026#34; tcp dport { xtel, xtelw } accept comment \u0026#34;:Hugo:1313,1314\u0026#34; ip saddr { 192.168.2.100 } drop } chain UDP { udp dport domain accept } } Ftp  关闭防火墙 安装 ftp 修改三份文件 ftpusers user_list vsftpd.conf 重启 ftp 防火墙配置文件允许 21 端口 开启防火墙 ftp 限制用户访问目录思路:修改 /etc/vsftpd/vsftpd.conf 文件中 chroot_local_user , chroot_list_enable , chroot_list_file 三项; 修改用户默认进入的家目录,则修改 /etc/passwd  vsftpd.conf 文件参考配置 :\nlisten_ipv6=YES pam_service_name=vsftpd tcp_wrappers=YES write_enable=YES local_umask=022 #用户ftp创建目录的权限掩码,022即为755 listen=NO #监听,yes可能导致无法启动ftp anonymous_enable=NO #拒绝匿名用户 local_root=/var/www/html #本地用户初始目录 #登录限制 local_enable=YES userlist_enable=YES userlist_deny=NO userlist_file=/etc/vsftpd/user_list #目录限制 chroot_local_user=YES chroot_list_enable=YES chroot_list_file=/etc/vsftpd/chroot_list allow_writeable_chroot=YES Nginx   Nginx (web服务器)偏向于 静态资源 ,处理高并发,可用 反向代理 从而实现 负载均衡 (类似 dns )\n  Apache 偏向于 PHP 的动态资源,bug少稳定\n  负载均衡 实现思路: 动静态资源分离 ,主服务器使用 Nginx ,动态资源则 反向代理 到本机或集群的 Apache 服务器(一台服务器安装两个 Apache 服务可防止 宕机 )\n  linux 有端口复用(套接字端口共享)功能( nginx 开启 reuseport );从内核层面做 负载均衡 ,避免 锁竞争 ( 惊群效应 ): https://www.zhihu.com/question/51618274\n  Nginx 启用 PHP 需要配置文件\n  Nginx 等软件自启,需要参考官方的启动代码,添加到 /etc/init.d/ 下\n  Nginx 支持缓存\n  Nginx 支持 gzip\n  Nginx实现负载均衡需要源码的同步, 使用 rsync (或+ sersync )实现集群服务器源码同步,源服务器执行的命令: rsync -avH --progress --delete --exclude-from=/etc/exclude.txt --password-file=/etc/pw.txt /var/www/html/ username@192.168.43.175::module1\n 其中按顺序是:含有忽略同步列表的 exclude.txt 文件,含有密码的 pw.txt 文件,源服务器的同步目录, username 用户名,ip地址,对应的模块 https://blog.51cto.com/chenfei123/1707746\n   负载均衡 和 前后端分离 配置 :\n#后端应反向给Apache代理 upstream proxys { server 127.0.0.1:8080 weight=2; server 192.168.43.175:9090 weight=3; ip_hash; } #前端应反向给Nginx代理 upstream proxys2 { server 127.0.0.1:8081 weight=3; server 192.168.43.175:9090 weight=2; } server { listen 80; server_name www.domain.top domain.top; index index.html index.htm index.php; location / { proxy_pass http://proxys; proxy_http_version 1.1; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; add_header X-Slave $upstream_addr; } location ~* \\.(css|js|png|jpg|jpeg|gif|txt|ico)$|^~/static { proxy_pass http://proxys2; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; add_header X-Slave $upstream_addr; } } #前端请求代理的配置 server { listen 8081; server_name www.domain.top domain.top; location / { root /var/www/html/tp/public; } } 缓存 和 gzip 配置 :\nhttp { # 开启缓存 proxy_connect_timeout 10; proxy_read_timeout 180; proxy_send_timeout 5; proxy_buffer_size 16k; proxy_buffers 4 32k; proxy_busy_buffers_size 96k; proxy_temp_file_write_size 96k; proxy_temp_path /tmp/temp_dir; proxy_cache_path /tmp/cache levels=1:2 keys_zone=cache_one:100m inactive=1d max_size=10g; server { listen 8081 reuseport; server_name localhost; root /usr/share/nginx/tp/public/; location / { } } server { #开启gzip压缩资源 gzip on; gzip_vary on; gzip_proxied any; gzip_comp_level 6; gzip_buffers 16 8k; gzip_http_version 1.0; gzip_min_length 100; gzip_types text/plain text/css application/javascript application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript application/vnd.ms-fontobject application/x-font-ttf font/opentype image/svg+xml image/x-icon; #资源文件缓存 location ~* \\.(css|js|json|png|jpg|jpeg|gif|txt|ico|bmp|swf)$|^~/static/ { proxy_pass http://127.0.0.1:8081; proxy_redirect off; proxy_set_header Host $host; proxy_cache cache_one; #cache_one在http设置层proxy_cache_path定义 proxy_cache_valid 200 302 24h; proxy_cache_valid 301 30d; proxy_cache_valid any 5m; expires 90d; add_header wall \u0026#34;hey!这文件进行了缓存和压缩哟!\u0026#34;; } } } 数据库读写分离 实现 读写分离 分为两大步 :\n 主从同步 读写分离;有两种方式 :  通过程序实现,如TP框架,性能最好; 使用代理工具,如 :  Mycat Mysql-Proxy       mysql 之间可相互主从同步,避免 单点 ;当有主从数据库发生宕机,可使用 percona-tooldit 工具解决恢复宕机后主从数据不同步的问题 https://blog.51cto.com/moerjinrong/2352317\n Mysql-Proxy 配置文件 mysql-proxy.cnf 参考 :\n[mysql-proxy] #运行mysql-proxy用户 user=root #主从mysql共有的用户 admin-username=proxy #用户的密码 admin-password=root #mysql-proxy运行ip(不能是127.0.0.1)和端口,不加端口,默认4040 proxy-address=192.168.1.1:4040 #slave从数据库Ip地址,默认端口3306 proxy-read-only-backend-addresses=192.168.1.2:3306 #master主数据库Ip地址,默认端口3306 proxy-backend-addresses=192.168.1.3:3306 #读写分离配置文件 proxy-lua-script=/usr/lib64/mysql-proxy/lua/rw-splitting.lua #管理脚本 admin-lua-script=/usr/lib64/mysql-proxy/lua/admin.lua #日志 log-file=/var/log/mysql-proxy.log #日志级别,高到低有error|warning|info|message|debug log-level=info #以守护进程方式运行 daemon=true #崩溃时,尝试重启 keepalive=true 数据库  mysql8 特性 :\n utf8mb4 储存表情符号 默认 InnoDB 降序索引 JSON支持,直接操作json里的数据 跳过锁等待 用户角色管理权限 innodb_dedicated_server 自适应参数,自动配置 mysql     redis 只做缓存使用,避免进行 持久性 \u0026amp;\u0026amp; 队列 \u0026amp;\u0026amp; 事务 (总之一句话:专人专事)\n  redis 和 DB 一致性方案:只读 redis ,当更新 DB 之后把受影响的缓存全部干掉(注意:是干掉,不是更新),并且设定过期时间: https://www.zhihu.com/question/319817091\n  出现不能连接数据库的情况,除了防火墙,也可能是数据库没有设置对外添加权限\n  出现用户不能登录的情况,可能是默认登录了 匿名用户 , 要把用户名为 '' 的用户清除\n  MyISAM 存储引擎偏向于大量查询和插入事件,表锁\n  InnoDB 存储引擎偏向于增删改事件,支持事务,支持索引行锁\n  索引才用 for update 锁库\n  数据库类型 http://www.jb51.net/article/55853.htm\n  免密码登录 skip-grant-tables\n  性能测试 explain select * from dnname\n  性能测试工具(mysql自带) mysqlslap ...\n  数据库导出 mysqldump -uroot -p dbname \u0026gt; dbname.sql\n  新建数据库 CREATE DATABASE mydb CHARACTER SET utf8 COLLATE utf8_general_ci\n  插入数据 insert into $my_name (id,name,tel) values('2','tab',null)\n  删除数据 delete from my_name where id = 1;\n  修改数据 update my_name set id='2',name='tab' where id=1;\n  插入字段 alter table my_name add id varchar(32)\n  删除字段 alter table my_name drop id\n  去掉name重复的 SELECT DISTINCT name FROM my_name\n  计算个数 select count(*) from my_name\n  计算总和 select sum(*) from my_name\n  计算平均 select sum(*)/count(*) from my_name\n  计算平均 select avg(name) from my_name\n  最小值 select min(name) from my_name\n  双重查询,查询指定最小值对应的的所有字段 SELECT * FROM my_name WHERE name=(SELECT max(name)FROM my_name)\n  根据指定字段分类 select * from my_name group by name;\n  表的联合查询 SELECT * FROM my_name as a INNER JOIN my_name2 as b on a.name=b.id\n  左查询,就是当my_name跟my_name2的的值不相对应则以my_name为主要,my_name2多出的值则省略 SELECT * FROM my_name as a left outer JOIN my_name2 as b on a.name=b.id\n  PHP  php7特性\n 用绝对路径 重定向后使用exit array_walk \u0026amp;引用节省内存 += array() isset($a{1}) $_SERVER[\u0026lsquo;REQUEST_TIME\u0026rsquo;] strtr 高亮PHP代码highlight_file 2 \u0026lt;=\u0026gt; 1 echo \u0026ldquo;\\u{41}\u0026quot;,PHP_EOL; use some\\namespace{ClassA, ClassB, ClassC as C}; function arraysSum(int \u0026hellip;$ints): string  class A{static private $b = \u0026#39;hello world\u0026#39;;} $bb = function (){return A::$b;}; echo $bb-\u0026gt;call(new A);     bug [] == []; //为false  \u0026#39;a\u0026#39; == 0; $a = \u0026#39;0.3\u0026#39; - \u0026#39;0.1\u0026#39;; json_encode($a); 0.55 * 100 == 55; //为false  json_encode((array)$array, JSON_UNESCAPED_UNICODE|JSON_UNESCAPED_SLASHES|JSON_PRETTY_PRINT) 有时候exec命令执行失败,却没有报错,请这样使用:exec('ls 2\u0026gt;\u0026amp;1', $a, $b) fastcgi就是执行 cgi协议 的,用于定义 Nginx 调用 php 时的数据格式,并减少对 php.ini 的读取 php-fpm就是 Nginx 服务调用的程序,管理 fastcgi 进程 php-cli就是 shell 命令行调用的程序 |||nochange|||表示 input 输入框为空 htmlentities / htmlspecialchars 可以过滤成 html格式 , 防止 XSS addslashes 防止 sql注入 explain 用于测试 sql语句 性能 引用字符串方式: Nowdoc / Heredoc 中文简体格式 header('Content-type:text/html;charset=utf-8') 解决textarea标签回车编码问题 str_replace(\u0026quot; \u0026quot;,\u0026quot; \u0026quot;,str_replace(\u0026quot;\\n\u0026quot;,\u0026quot;\u0026lt;br/\u0026gt;\u0026quot;,$data)) 单入口写上: session_start() 才可以使用 $_SESSION 跳转到#页面 header('Location:#') php格式插入html遍历 \u0026lt;?php foreach ($my_name as $x =\u0026gt; $y){ ?\u0026gt;\u0026lt;li\u0026gt;\u0026lt;?php echo $y[\u0026#39;z\u0026#39;] ?\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;?php } ?\u0026gt;  解决ajax夸域 header(\u0026#39;Access-Control-Allow-Origin:demain.com\u0026#39;); //可以用*允许所有 header(\u0026#39;Content-Type:application/json; charset=utf-8\u0026#39;); header(\u0026#39;Access-Control-Allow-Methods: GET, POST, DELETE\u0026#39;); header(\u0026#39;Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept\u0026#39;);  内容返回 ob_start(); //开启echo缓存区 echo \u0026#34;Hello\u0026#34;; //输出 ob_end_flush(); //输出全部内容到浏览器,包括echo      函数 描述     rand(x,y) 在xy之间取随机数   implode(\u0026lsquo;xx\u0026rsquo;,'$my_name') 用xx隔开my_name中每个元素   explode() 把字符串打散为数组.   arry_merge() 打散混乱数组重新排列   in_array($xy,$my_name) 数组$my_name是否含$xy   mb_substr($my_name,x,y,\u0026lsquo;utf-8\u0026rsquo;) 截取字符串,从第x个字符开始截取y个字符   strtotime() 将任何英文文本的日期或时间描述解析为 Unix 时间戳.   字符串类型 \u0026ndash;   addcslashes() 返回在指定的字符前添加反斜杠的字符串.   addslashes() 返回在预定义的字符前添加反斜杠的字符串.   chop() 删除字符串右侧的空白字符或其他字符..   chunk_split() 把字符串分割为一系列更小的部分.   html_entity_decode() 把 HTML 实体转换为字符.   htmlentities() 把字符转换为 HTML 实体.   htmlspecialchars_decode() 把一些预定义的 HTML 实体转换为字符.   htmlspecialchars() 把一些预定义的字符转换为 HTML 实体.   join() implode() 的别名.   ltrim() 移除字符串左侧的空白字符或其他字符.   md5() 计算字符串的 MD5 散列.   number_format() 以千位分组来格式化数字.   parse_str() 把查询字符串解析到变量中.   rtrim() 移除字符串右侧的空白字符或其他字符.   sha1() 计算字符串的 SHA-1 散列.   similar_text() 计算两个字符串的相似度.   sprintf() 把格式化的字符串写入变量中.   str_pad() 把字符串填充为新的长度.   str_repeat() 把字符串重复指定的次数.   str_replace() 替换字符串中的一些字符(对大小写敏感)   str_shuffle() 随机地打乱字符串中的所有字符.   str_split() 把字符串分割到数组中.   strip_tags() 剥去字符串中的 HTML 和 PHP 标签.   stripcslashes() 删除由 addcslashes() 函数添加的反斜杠.   stripslashes() 删除由 addslashes() 函数添加的反斜杠.   stripos() 返回字符串第一次出现的位置(大小写不敏感)   strpos() 返回字符串第一次出现的位置(大小写敏感)   stristr() 查找字符串第一次出现的位置(大小写不敏感)   strrchr() 查找字符串最后一次出现.   strripos() 查找字符串最后一次出现的位置(大小写不敏感)   strrpos() 查找字符串最后一次出现的位置(大小写敏感)   strstr() 查找字符串第一次出现(大小写敏感)   strchr() 查找字符串第一次出现,strstr() 的别名   strrev() 反转字符串.   strlen() 返回字符串的长度.   strtolower() 把字符串转换为小写字母.   strtoupper() 把字符串转换为大写字母.   strtr() 转换字符串中特定的字符.   substr() 返回字符串的一部分.   substr_count() 计算子串在字符串中出现的次数.   substr_replace() 把字符串的一部分替换为另一个字符串.   ucfirst() 把字符串中的首字符转换为大写.   ucwords() 把字符串中每个单词的首字符转换为大写.   数组函数 \u0026ndash;   array_change_key_case() 把数组中所有键更改为小写或大写.   array_chunk() 把一个数组分割为新的数组块.   array_column() 返回输入数组中某个单一列的值.   array_combine() 通过合并两个数组来创建一个新数组.   array_count_values() 用于统计数组中所有值出现的次数.   array_diff() 比较数组,返回差集(只比较键值)   array_fill() 用给定的键值填充数组.   array_fill_keys() 用指定键名的给定键值填充数组.   array_filter() 用回调函数过滤数组中的元素.   array_flip() 交换数组中的键和值.   array_intersect() 比较数组,返回交集(只比较键值)   array_key_exists() 检查指定的键名是否存在于数组中.   array_keys() 返回数组中所有的键名.   array_map() 把数组中的每个值发送到用户自定义函数,返回新的值.   array_merge() 把一个或多个数组合并为一个数组.   array_multisort() 对多个数组或多维数组进行排序.   array_pad() 用值将数组填补到指定长度.   array_pop() 删除数组的最后一个元素(出栈)   array_push() 将一个或多个元素插入数组的末尾(入栈)   array_replace() 使用后面数组的值替换第一个数组的值.   array_reverse() 以相反的顺序返回数组.   array_search() 搜索数组中给定的值并返回键名.   array_shift() 删除数组中首个元素,并返回被删除元素的值.   array_slice() 返回数组中被选定的部分.   array_splice() 删除并替换数组中指定的元素.   array_sum() 返回数组中值的和.   array_udiff() 比较数组,返回差集   array_unique() 删除数组中的重复值.(集合的概念)   array_unshift() 在数组开头插入一个或多个元素.   array_values() 返回数组中所有的值.   arsort() 对关联数组按照键值进行降序排序.   asort() 对关联数组按照键值进行升序排序.   compact() 创建包含变量名和它们的值的数组.   count() 返回数组中元素的数目.   current() 返回数组中的当前元素.   extract() 从数组中将变量导入到当前的符号表.   in_array() 检查数组中是否存在指定的值.   key() 从关联数组中取得键名.   krsort() 对数组按照键名逆向排序.   ksort() 对数组按照键名排序.   list() 把数组中的值赋给一些变量.   range() 创建包含指定范围单元的数组.   rsort() 对数组逆向排序.   shuffle() 将数组打乱.   sizeof() count() 的别名.   sort() 对数组排序.   uasort() 使用用户自定义的比较函数对数组中的键值进行排序.   uksort() 使用用户自定义的比较函数对数组中的键名进行排序.   usort() 使用用户自定义的比较函数对数组进行排序.    前端  可以设置类似cookie , 它可永久保存 localStorage.setItem(name, val) 死链 \u0026lt;a href=\u0026quot;javascript:void(0);\u0026quot;\u0026gt; CSS加载JS样式 behavior:url() 选择div内第二个li,类似js div li:first-child+li{} 选择form下类型为text的input标签 form input[type=\u0026quot;text\u0026quot;]{} 居中CSS背景图片 background-position:center 居中HTML图片 \u0026lt;div align=\u0026quot;center\u0026quot;\u0026gt;\u0026lt;img src=\u0026quot;\u0026quot;\u0026gt; 居中div {top:0;left:0;bottom:0;right:0;margin:auto}/margin:0 auto; 单行文字水平/垂直居中 text-decoration:center;/line-height:10px; 多行文字垂直居中:div1\u0026gt;div2\u0026gt;p div1{display:table;/*转换成表格*/} div2{display:table-cell;vertical-align:middle;} li中间向两边分布 ul{text-align:center}li{display: inline-block;} li水平分布,ul宽度平均分割给li ul{display:flex}li{flex:1;text-align:center} li水平分布,类似最左和最右浮动两边的效果 div{overflow:hidden;width:11px} div ul{width:12px} li{width:5px;margin_right:1px} 轮播图不能有滚动条 在ul父级加overflow:hidden;width:100%;position: relative;//position用于ul居中 清除浮动,class是my_name就可以清除浮动 .my_name:after{content:\u0026quot;\u0026quot;; display:block; height:0; visibility:hidden; clear:both;} 鼠标悬浮图片放大 .div:hover img{transform: scale(1.03);transition: all 1s ease 0s;-webkit-transform: scale(1.03);-webkit-transform: all 1s ease 0s;} iframe高度 var e = window, a = \u0026#39;inner\u0026#39;, $header = $(\u0026#34;.header\u0026#34;);//如果页面有头部,则要减去 if (!(\u0026#39;innerWidth\u0026#39; in window)) { a = \u0026#39;client\u0026#39;; e = document.documentElement || document.body; } var height = e[a + \u0026#39;Height\u0026#39;] - $header.outerHeight(); $(\u0026#34;.iframe\u0026#34;).css({ height: height, width: \u0026#34;100%\u0026#34; });   \u0026hellip; 以上\n","date":1601769600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1617198788,"objectID":"cb2239b3ea81665e80041a162c964667","permalink":"https://twbworld.github.io/post/node/","publishdate":"2020-10-04T00:00:00Z","relpermalink":"/post/node/","section":"post","summary":"平时学习中,比较重要的知识点,记下来备忘","tags":["Node"],"title":"学习笔记","type":"post"},{"authors":["忐忑"],"categories":null,"content":" 有些小伙伴手里有上百G甚至上T移动硬盘\n平时制作启动硬盘,除了启动分区,都是只剩一个分区提供自己使用的\n那么问题来了:怎么保留启动盘的功能,又能把硬盘分成多个分区呢?\n搜索引擎也很少有相关文章\n那么,今天就带大家制作一个多分区启动盘\n作者尝试了无数次才成功的,呕心沥血之作\n 所使用到的:\n  硬盘(本文章使用U盘展示,建议硬盘,毕竟日常生活中的十几或几十G的U盘,也没必要进行分区了)\n  微PE(作者使用的版本是2.1;也可以使用\u0026quot;大白菜\u0026quot;或\u0026quot;老毛桃\u0026quot;,有广告植入,不建议)\n   微PE下载(不需要安装): http://www.wepe.com.cn/download.html\n  UltraISO(作者使用的版本是9.7)   UltraISO下载: https://cn.ultraiso.net/xiazai.html\n  DiskGenius(作者使用的版本是5.1)   DiskGenius下载: https://www.diskgenius.cn/download.php\n 1#获取微PE的系统ISO (1) 双击打开下载好的 微PE 安装包,看到以下界面,单击右下角的光盘图标 (2) 接下来,要把 微PE 自带的ISO镜像保存到电脑,选择保存的位置, 光盘卷标 也就是盘符的名称,也建议改成喜欢的名称,如\u0026quot;pe盘\u0026quot;,最后点击 立即生成ISO 2#写入ISO到硬盘 (1) 插入硬盘,准备格式化\n PS: 备份数据!!!!!备份数据!!!!!备份数据!!!!!\n (2) 打开安装好的 UltraISO ,菜单栏依次点击 文件-\u0026gt;打开 ; 选择上一步保存好的ISO文件\n(3) 可以看到,左侧栏出现的ISO文件\n(4) 接着,菜单栏依次点击 启动-\u0026gt;写入硬盘映像 (5) 出现一个弹窗, 硬盘驱动器 选择正确的硬盘,首先,需要把硬盘格式化,点击格式化 (6) 最后,正式把ISO文件写入硬盘,点击 写入 3#备份启动分区 (1) 打开安装好的 DiskGenius ,在左侧栏找到对应的硬盘,单击选中上一步生成的盘 (2) 菜单栏依次点击 工具-\u0026gt;备份分区到镜像文件 (3) 出现一个弹窗, 点击 选择文件路径 ,选择一个目录,输入自定义的pmf文件的名称,点击 打开 (4) 点击 开始 ,成功后,会生成一个.pmf后缀文件,这个文件就是你的启动盘备份文件 4#硬盘分区 (1) DiskGenius 左侧栏选中对应的硬盘,点击 快速分区 (2) 可以看到一个弹窗;这一步是成功的关键,要严格按照以下的规定(作者经过无数次的尝试,得出来的结论) :\n  分区表类型 一定为 MBR ; 不要问为什么,我也不知道 分区数目 最多为3个; 不要问为什么,我也不知道 高级设置 以第一个作为启动分区,所以第一个分区选择 FAT32, 其余为 NTFS ; 不要问为什么,我也不知道 高级设置 把所有的 主分区 勾上; 不要问为什么,我也不知道 至于各分区的容量,卷标名称等,请自定义    (3) 分区后,可以看到作为启动分区已经显示 活动 了 5#恢复启动分区 (1) DiskGenius ,在左侧栏找到对应的硬盘,单击选中上一步作为启动的分区 (2) 菜单栏依次点击 工具-\u0026gt;从镜像文件还原分区 (3) 出现弹窗, 点击 选择文件 , 选择在 第三步 生成的 pmf 文件 (4) 到此为止,成功制作了一个 多分区启动硬盘\n 但是,这样制作的多分区启动硬盘, BIOS 只能使用 Legacy 启动模式来启动硬盘(新型的 UEFI 无法启动PE), 如下图例子(华硕的BIOS)\n \u0026hellip; 以上\n","date":1601302813,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1615666223,"objectID":"bda3981c485475de00f23b31448a0805","permalink":"https://twbworld.github.io/post/multi_partition_startup_disk/","publishdate":"2020-09-28T22:20:13+08:00","relpermalink":"/post/multi_partition_startup_disk/","section":"post","summary":"一般制作启动盘后,只有一个大分区?如何制作多个分区的启动盘","tags":["System"],"title":"制作多分区启动盘","type":"post"},{"authors":["忐忑"],"categories":null,"content":" 连接局域网下的虚拟机,在网上找到的做法通常是:在VMware配置端口转发\n最近了解隧道技术,突发奇想:能不能使用SSH隧道连接局域网下的虚拟机呢?\n在网上找到的相关资料不多,经过自己摸索,终于实现了\n使用SSH隧道连接局域网下的虚拟机,主要有两种方式可以实现\n1: 本地端口转发; 2: 动态端口转发\n 首先,假设网络图如下,A和B在同一局域网下,我们的目的是: 实现 A 连接到 C 的SSH服务 方法一 : 本地端口转发  大体思路: 在A下创建 A --\u0026gt; C 的SSH隧道,就可以访问A下的指定端口,通过隧道转发,访问到C的22端口了\n具体实现如下 :\n 1#B安装SSH服务  参考文章 https://www.cnblogs.com/sparkdev/p/10166061.html\n   这是非常关键的一步(作为小白,我刚开始就异想天开,直接就想通过A连接到C,直到多次尝试失败并且想通了)\n  我的电脑 B 的系统是windows10 1909,自带了OpenSSH Server软件;如果版本是wondows10 1809以下或wondows7的同学,可以网上搜索windows怎么安装openSSH服务\n  (1) Win10打开 设置(Win + I) ==\u0026gt; 应用 ==\u0026gt; 应用和功能 ==\u0026gt; 可选功能 =\u0026gt; 添加功能 =\u0026gt; OpenSSH服务器(点击安装)\n(2) 打开 任务管理器(Shift + Ctrl + Esc) ==\u0026gt; 任务 ==\u0026gt; 左下角点击\u0026quot;打开服务\u0026quot;; 找到两个OpenSSH服务,右键开启\n(3) 打开 控制面板 ==\u0026gt; 系统和安全 ==\u0026gt; Windows Defender 防火墙 ==\u0026gt; 启用或关闭windows defender防火墙;选择关闭防火墙; (或者在入站规则添加允许22端口)\n 到此, B已经配置完成\n 2#A建立 A --\u0026gt; C 的隧道   本人使用的是PuTTY的工具, 使用其他工具或PowerShell也是可以的\n  首先保证 C 关闭iptables或nftables防火墙 (或配置允许22端口)\n  通过\u0026quot;中间人\u0026quot; B ; 在 A 电脑上使用PuTTY建立起与 C 的SSH隧道 (本地端口转发)\n  在 A 上配置(基于文章开头假设的网络图) :\n  点击open,会出现登录,注意:这里登录的是 B 电脑,也就是要输入B的windows的用户名和密码;\n  到这里,你已经建立起 A --\u0026gt; C 的隧道了, 注意: 请不要关闭PuTTY窗口, 否则隧道会被关闭\n   PuTTY如上设置,相当于使用命令 ssh -L 127.0.0.1:6666:192.168.2.2:22 192.168.1.107\n 3#A通过隧道连接 C 电脑  终于到最后一步了, 很简单, 在 A 电脑开启新的PuTTY窗口, 请求 A 本地的 刚才自定义的 6666端口就可以啦   恭喜你, 成功通过SSH隧道连接到 C ;因为隧道是 A --\u0026gt; C 的且加密的, B 不会监听到流量  方法二 : 动态端口转发  大体思路: 在A下创建 A --\u0026gt; B 的SSH隧道,把 B 作为代理(Proxy), 就可以实现 : A 使用SOCKS5协议通过 B 来访问到 C 的22端口\n具体实现如下 :\n 1#B安装SSH服务 (在 方法一 中有具体实现, 略)\n2#A建立 A --\u0026gt; B 的隧道   本人使用的是PuTTY的工具, 使用其他工具或PowerShell也是可以的\n  在 A 电脑上使用PuTTY建立起与 B 的SSH隧道 (动态端口转发)\n  在 A 上配置(基于文章开头假设的网络图) :\n  点击open,会出现登录,注意:这里登录的是 B 电脑,也就是要输入B的windows的用户名和密码;\n  到这里,你已经建立起 A --\u0026gt; B 的隧道了, 注意: 请不要关闭PuTTY窗口, 否则隧道会被关闭\n   PuTTY如上设置,相当于使用命令 ssh -D 127.0.0.1:6666 192.168.1.107\n 3#A通过代理连接 C 电脑  终于到最后一步了, 很简单, 在 A 电脑上开启新的PuTTY窗口, 设置 A 本地的 刚才自定义的 6666端口为代理端口, 请求 C 就可以啦  方法三 : VMware配置端口转发  这是一个比较普遍的做法, 在网上也容易找到相关文章\n大体思路: 在VMware上配置 监听父windows的端口X,把A端口转发到VMware下的虚拟机端口Y, 局域网的电脑只有访问windows的端口X就相当于访问虚拟机的端口Y啦, 是不是很容易\n具体实现如下 :\n 1#B配置VMware 2#B配置防火墙  打开 控制面板 ==\u0026gt; 系统和安全 ==\u0026gt; Windows Defender 防火墙 ==\u0026gt; 启用或关闭windows defender防火墙;选择关闭防火墙; (或者在 入站规则 添加允许 上一步自定义的6666端口)  3#A通过 B 连接 C 电脑  终于到最后一步了, 很简单, 在 A 电脑直接用PuTTY请求 B 的 6666端口, 就可以登录 C 啦  \u0026hellip; 以上\n","date":1594549093,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1615666223,"objectID":"7905d7c95ce016c8c96fb33ccc68e0f3","permalink":"https://twbworld.github.io/post/use_tunnel_to_connect_to_virtual_machines_in_the_lan/","publishdate":"2020-07-12T18:18:13+08:00","relpermalink":"/post/use_tunnel_to_connect_to_virtual_machines_in_the_lan/","section":"post","summary":"使用SSH隧道技术,连接局域网下的VMware linux虚拟机","tags":["Tunnel"],"title":"SSH隧道连接局域网下的虚拟机","type":"post"},{"authors":["忐忑"],"categories":null,"content":" 我的VMware版本: 15.5.2\n 一 创建虚拟网络  VMware菜单==\u0026gt;编辑==\u0026gt;虚拟网络编辑器  (这一步可略过)移除所有默认的\u0026quot;网络\u0026quot;  点击\u0026quot;添加网络\u0026quot;, 选择\u0026quot;VMnet8\u0026quot;    上方列表点击选择刚才添加的网络\u0026quot;VMnet8\u0026quot;; 选择NAT模式; 设置子网IP;一般设置\u0026quot;192.168.xxx.0\u0026quot;,我这设置为\u0026quot;192.168.2.0\u0026quot; 设置子网掩码\u0026quot;255.255.255.0\u0026quot;,一般子网掩码固定;    点击\u0026quot;NAT设置\u0026quot;;设置\u0026quot;网关IP\u0026quot;, 一般为\u0026quot;192.168.xxx.1\u0026quot;, 所以我这设置网关为\u0026quot;192.168.2.1\u0026quot;;点击\u0026quot;确定\u0026quot; (还有端口转发,一般用于局域网PC链接VMware里的虚拟机所使用)  点击\u0026quot;DHCP设置\u0026quot;; 这里可以设置网关分配给VMware下的虚拟机的起始IP和结束IP; 因为网关已经占用了192.168.xxx.1,所以这自定义起始IP可以为\u0026quot;192.168.xxx.2\u0026quot;, 结束IP为\u0026quot;192.168.xxx.254\u0026quot;, 点击\u0026quot;确认\u0026quot;, 回到上一层, 再次点击\u0026quot;确认\u0026quot;;  二 使用虚拟网络  查看 控制面板==\u0026gt;网络和Internet==\u0026gt;网络和共享中心==\u0026gt;更改适配器设置; 可看到, 虚拟网卡已创建成功;  选择新添加的网卡;右键选择\u0026quot;属性\u0026quot;;双击\u0026quot;协议版本4\u0026quot;;设置IP;我这里设置了100;也可以设大一点,点击\u0026quot;确认\u0026quot;   如果缺少这一步,可能会出现宿主机SSH链接不上虚拟机的情况(或者出现需要长时间才连通,连上后,短时间内又断开的情况);原因可能是因为网卡的IP占用了网关IP\u0026quot;192.168.xxx.1\u0026quot;, 导致虚拟机的数据到不了在外一层的宿主机\n 虚拟网卡已创建成功,最后还要选择使用新创建的网卡;选择你要使用刚才新建网卡的虚拟机, 右键选择\u0026quot;设置\u0026quot;, \u0026ldquo;硬件\u0026rdquo;==\u0026gt;\u0026ldquo;网络适配器\u0026rdquo; ,右侧点击\u0026quot;自定义:特定虚拟网络\u0026quot;, 选择新建的\u0026quot;VMnet8(NAT 模式)\u0026quot;, 点击\u0026quot;确定\u0026quot;   这一步非常关键,我曾经缺少这一步,导致虚拟机连不上网\n 到此,虚拟机应该就可以上网了,如果不行;请重启虚拟机的network; 或者VMware最右下角的\u0026quot;网络适配器\u0026quot;重新连接  同时还可以在虚拟机里设置固定的IP,IP地址要根据\u0026quot;起始IP\u0026quot;和结束\u0026quot;IP\u0026quot;设置; 例如,我在Centos8系统上, 设置了IP:\u0026ldquo;192.168.2.2\u0026rdquo;  ","date":1590905260,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1615666223,"objectID":"8706b532d563b46d6b0e3d569a55ef87","permalink":"https://twbworld.github.io/post/vmware_customize_network/","publishdate":"2020-05-31T14:07:40+08:00","relpermalink":"/post/vmware_customize_network/","section":"post","summary":"VMware创建设置虚拟网卡,可更好的了解和定制虚拟机的网络","tags":["VMware"],"title":"VMware自定义虚拟网卡(添加网络)","type":"post"},{"authors":["忐忑"],"categories":null,"content":"笔记一: 安装时,发生警告 --character-set-server: \u0026#39;utf8\u0026#39; is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous --collation-server: \u0026#39;utf8_general_ci\u0026#39; is a collation of the deprecated character set UTF8MB3. Please consider using UTF8MB4 with an appropriate collation instead 原因 :\n 安装mysql8的时候,配置了官方不推荐的\u0026quot;utf8\u0026quot;,其实\u0026quot;utf8\u0026quot;就是mysql中\u0026quot;UTF8MB3\u0026quot;的别名,然而又同时存在着\u0026quot;UTF8MB4\u0026quot;,所有,建议改为\u0026quot;UTF8MB4\u0026quot;;\n 解决 :\n 把cmake的参数 -DDEFAULT_CHARSET=utf8 改为 -DDEFAULT_CHARSET=utf8mb4  , -DDEFAULT_COLLATION=utf8_general_ci 改为 -DDEFAULT_COLLATION=utf8mb4_unicode_ci\n 给出完整cmake命令 :\n# 切换到mysql8解压后的目录 cd /usr/local/mysql8/ # 新建并切换build目录 mkdir build cd build # 编译前的配置;其中的\u0026#34;DCMAKE_INSTALL_PREFIX\u0026#34;, \u0026#34;DMYSQL_DATADIR\u0026#34;, \u0026#34;DWITH_BOOST\u0026#34; 按照自己的情况配置 cmake .. -DCMAKE_INSTALL_PREFIX=/usr/local/mysql8 \\ -DMYSQL_DATADIR=/usr/local/mysql8/data \\ -DSYSCONFDIR=/etc \\ -DWITH_MYISAM_STORAGE_ENGINE=1 \\ -DWITH_INNOBASE_STORAGE_ENGINE=1 \\ -DWITH_MEMORY_STORAGE_ENGINE=1 \\ -DWTH_READLINE=1 \\ -DMYSQL_TCP_PORT=3306 \\ -DENABLED_LOCAL_INFILE=1 \\ -DWITH_PARTITION_STORAGE_ENGINE=1 \\ -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8mb4 \\ -DDEFAULT_COLLATION=utf8mb4_unicode_ci \\ -DWITH_BOOST=/usr/local/boost_1_70_0  安装后,可以看到 /etc/my.cnf 设置为 collation-server = utf8mb4_unicode_ci character-set-server = utf8mb4\n  笔记二: 创建my.cnf 在/etc目录下没有发现my.cnf(我的mysql版本是mysql-8.0.20), 只能自己创建了 :\nvim /etc/my.cnf\n# 客户端设置 [client] port = 3306 # 默认情况下，socket文件应为/usr/local/mysql/mysql.socket,所以可以ln -s xx /tmp/mysql.sock socket = /tmp/mysql.sock # 服务端设置 [mysqld] ########################################################################################################## # 基础信息 #Mysql服务的唯一编号 每个mysql服务Id需唯一 server-id = 1 #服务端口号 默认3306 port = 3306 # 启动mysql服务进程的用户 user = mysql ########################################################################################################## # 安装目录相关 # mysql安装根目录 basedir = /usr/local/mysql8 # mysql数据文件所在位置 datadir = /usr/local/mysql8/data # 临时目录 比如load data infile会用到,一般都是使用/tmp tmpdir = /tmp # 设置socke文件地址 socket = /tmp/mysql.sock ########################################################################################################## # 事务隔离级别，默认为可重复读（REPEATABLE-READ）。（此级别下可能参数很多间隙锁，影响性能，但是修改又影响主从复制及灾难恢复，建议还是修改代码逻辑吧） # 隔离级别可选项目：READ-UNCOMMITTED READ-COMMITTED REPEATABLE-READ SERIALIZABLE # transaction_isolation = READ-COMMITTED transaction_isolation = REPEATABLE-READ ########################################################################################################## # 数据库引擎与字符集相关设置 # mysql 5.1 之后，默认引擎就是InnoDB了 default_storage_engine = InnoDB # 内存临时表默认引擎，默认InnoDB default_tmp_storage_engine = InnoDB #数据库默认字符集,主流字符集支持一些特殊表情符号（特殊表情符占用4个字节） character-set-server = utf8mb4 #数据库字符集对应一些排序等规则，注意要和character-set-server对应 collation-server = utf8mb4_unicode_ci # 设置client连接mysql时的字符集,防止乱码 # init_connect=\u0026#39;SET NAMES utf8\u0026#39; ########################################################################################################## # 数据库连接相关设置 # 最大连接数，可设最大值16384，一般考虑根据同时在线人数设置一个比较综合的数字，鉴于该数值增大并不太消耗系统资源，建议直接设10000 # 如果在访问时经常出现Too Many Connections的错误提示，则需要增大该参数值 max_connections = 10000 # 默认值100，最大错误连接数，如果有超出该参数值个数的中断错误连接，则该主机将被禁止连接。如需对该主机进行解禁，执行：FLUSH HOST # 考虑高并发场景下的容错，建议加大。 max_connect_errors = 10000 # MySQL打开的文件描述符限制，默认最小1024; # 当open_files_limit没有被配置的时候，比较max_connections*5和ulimit -n的值，哪个大用哪个， # 当open_file_limit被配置的时候，比较open_files_limit和max_connections*5的值，哪个大用哪个。 open_files_limit = 65535 # 注意：仍然可能出现报错信息Can\u0026#39;t create a new thread；此时观察系统cat /proc/mysql进程号/limits，观察进程ulimit限制情况 # 过小的话，考虑修改系统配置表，/etc/security/limits.conf和/etc/security/limits.d/90-nproc.conf # MySQL默认的wait_timeout 值为8个小时, interactive_timeout参数需要同时配置才能生效 # MySQL连接闲置超过一定时间后(单位：秒，此处为1800秒)将会被强行关闭 interactive_timeout = 1800 wait_timeout = 1800 # 在MySQL暂时停止响应新请求之前的短时间内多少个请求可以被存在堆栈中  # 官方建议back_log = 50 + (max_connections / 5),封顶数为900 back_log = 900 ########################################################################################################## # 数据库数据交换设置 # 该参数限制服务器端，接受的数据包大小，如果有BLOB子段，建议增大此值，避免写入或者更新出错。有BLOB子段，建议改为1024M max_allowed_packet = 128M ########################################################################################################## # 内存，cache与buffer设置 # 内存临时表的最大值,默认16M，此处设置成128M tmp_table_size = 64M # 用户创建的内存表的大小，默认16M，往往和tmp_table_size一起设置，限制用户临师表大小。 # 超限的话，MySQL就会自动地把它转化为基于磁盘的MyISAM表，存储在指定的tmpdir目录下，增大IO压力，建议内存大，增大该数值。 max_heap_table_size = 64M # 表示这个mysql版本是否支持查询缓存。ps：SHOW STATUS LIKE \u0026#39;qcache%\u0026#39;，与缓存相关的状态变量。 # have_query_cache # 在一个事务中binlog为了记录SQL状态所持有的cache大小 # 如果你经常使用大的,多声明的事务,你可以增加此值来获取更大的性能. # 所有从事务来的状态都将被缓冲在binlog缓冲中然后在提交后一次性写入到binlog中 # 如果事务比此值大, 会使用磁盘上的临时文件来替代. # 此缓冲在每个连接的事务第一次更新状态时被创建 binlog_cache_size = 1M #*** MyISAM 相关选项 # 指定索引缓冲区的大小, 为MYISAM数据表开启供线程共享的索引缓存,对INNODB引擎无效。相当影响MyISAM的性能。 # 不要将其设置大于你可用内存的30%,因为一部分内存同样被OS用来缓冲行数据 # 甚至在你并不使用MyISAM 表的情况下, 你也需要仍旧设置起 8-64M 内存由于它同样会被内部临时磁盘表使用. # 默认值 8M，建议值：对于内存在4GB左右的服务器该参数可设置为256M或384M。注意：该参数值设置的过大反而会是服务器整体效率降低！ key_buffer_size = 64M # 为每个扫描MyISAM的线程分配参数设置的内存大小缓冲区。  # 默认值128kb，建议值：16G内存建议1M，4G：128kb或者256kb吧 # 注意，该缓冲区是每个连接独占的，所以总缓冲区大小为 128kb*连接数；极端情况128kb*maxconnectiosns，会超级大，所以要考虑日常平均连接数。 # 一般不需要太关心该数值，稍微增大就可以了， read_buffer_size = 262144 # 支持任何存储引擎 # MySQL的随机读缓冲区大小，适当增大，可以提高性能。 # 默认值256kb；建议值：得参考连接数，16G内存，有人推荐8M # 注意，该缓冲区是每个连接独占的，所以总缓冲区大小为128kb*连接数；极端情况128kb*maxconnectiosns，会超级大，所以要考虑日常平均连接数。 read_rnd_buffer_size = 1M # order by或group by时用到  # 支持所有引擎，innodb和myisam有自己的innodb_sort_buffer_size和myisam_sort_buffer_size设置 # 默认值256kb；建议值：得参考连接数，16G内存，有人推荐8M. # 注意，该缓冲区是每个连接独占的，所以总缓冲区大小为 1M*连接数；极端情况1M*maxconnectiosns，会超级大。所以要考虑日常平均连接数。 sort_buffer_size = 1M # 此缓冲被使用来优化全联合(full JOINs 不带索引的联合) # 类似的联合在极大多数情况下有非常糟糕的性能表现,但是将此值设大能够减轻性能影响. # 通过 “Select_full_join” 状态变量查看全联合的数量 # 注意，该缓冲区是每个连接独占的，所以总缓冲区大小为 1M*连接数；极端情况1M*maxconnectiosns，会超级大。所以要考虑日常平均连接数。 # 默认值256kb;建议值：16G内存，设置8M. join_buffer_size = 1M # 缓存linux文件描述符信息，加快数据文件打开速度 # 它影响myisam表的打开关闭，但是不影响innodb表的打开关闭。 # 默认值2000，建议值：根据状态变量Opened_tables去设定 table_open_cache = 2000 # 缓存表定义的相关信息，加快读取表信息速度 # 默认值1400，最大值2000，建议值：基本不改。 table_definition_cache = 1400 # 该参数是myssql 5.6后引入的，目的是提高并发。 # 默认值1，建议值：cpu核数，并且\u0026lt;=16 table_open_cache_instances = 2 # 当客户端断开之后，服务器处理此客户的线程将会缓存起来以响应下一个客户而不是销毁。可重用，减小了系统开销。 # 默认值为9，建议值：两种取值方式，方式一，根据物理内存，1G —\u0026gt; 8；2G —\u0026gt; 16； 3G —\u0026gt; 32； \u0026gt;3G —\u0026gt; 64； # 方式二，根据show status like \u0026#39;threads%\u0026#39;，查看Threads_connected值。 thread_cache_size = 16 # 默认值256k,建议值：16/32G内存，512kb，其他一般不改变，如果报错：Thread stack overrun，就增大看看, # 注意，每个线程分配内存空间，所以总内存空间。。。你懂得。 thread_stack = 512k ########################################################################################################## # 日志文件相关设置，一般只开启三种日志，错误日志，慢查询日志，二进制日志。普通查询日志不开启。 # 普通查询日志，默认值off，不开启 general_log = 0 # 普通查询日志存放地址 general_log_file = /usr/local/mysql8/log/mysql-general.log # 全局动态变量，默认3，范围：1～3 # 表示错误日志记录的信息，1：只记录error信息；2：记录error和warnings信息；3：记录error、warnings和普通的notes信息。 log_error_verbosity = 2 # 错误日志文件地址 log_error = /usr/local/mysql8/log/mysql-error.log # 开启慢查询 slow_query_log = 1 # 开启慢查询时间，此处为1秒，达到此值才记录数据 long_query_time = 3 # 检索行数达到此数值，才记录慢查询日志中 min_examined_row_limit = 100 # mysql 5.6.5新增，用来表示每分钟允许记录到slow log的且未使用索引的SQL语句次数，默认值为0，不限制。 log_throttle_queries_not_using_indexes = 0 # 慢查询日志文件地址 slow_query_log_file = /usr/local/mysql8/log/mysql-slow.log # 开启记录没有使用索引查询语句 log-queries-not-using-indexes = 1 # 开启二进制日志 log_bin = /usr/local/mysql8/log/mysql-bin.log # mysql清除过期日志的时间，默认值30*24*60*60， binlog_expire_logs_seconds=604800 # 如果二进制日志写入的内容超出给定值，日志就会发生滚动。你不能将该变量设置为大于1GB或小于4096字节。 默认值是1GB。 max_binlog_size = 1000M # binlog的格式也有三种：STATEMENT，ROW，MIXED。mysql 5.7.7后，默认值从 MIXED 改为 ROW # 关于binlog日志格式问题，请查阅网络资料 binlog_format = row # 默认值N=1，使binlog在每N次binlog写入后与硬盘同步，ps：1最慢 # sync_binlog = 1  ########################################################################################################## # innodb选项 # 说明：该参数可以提升扩展性和刷脏页性能。 # 默认值1，建议值：4-8；并且必须小于innodb_buffer_pool_instances innodb_page_cleaners = 4 # 说明：一般8k和16k中选择，8k的话，cpu消耗小些，selcet效率高一点，一般不用改 # 默认值：16k；建议值：不改， innodb_page_size = 16384 # 说明：InnoDB使用一个缓冲池来保存索引和原始数据, 不像MyISAM.这里你设置越大,你在存取表里面数据时所需要的磁盘I/O越少. # 在一个独立使用的数据库服务器上,你可以设置这个变量到服务器物理内存大小的60%-80% # 注意别设置的过大，会导致system的swap空间被占用，导致操作系统变慢，从而减低sql查询的效率 # 默认值：128M，建议值：物理内存的60%-80% innodb_buffer_pool_size = 512M # 说明:只有当设置 innodb_buffer_pool_size 值大于1G时才有意义，小于1G，instances默认为1，大于1G，instances默认为8 # 但是网络上有评价，最佳性能，每个实例至少1G大小。 # 默认值：1或8，建议值：innodb_buffer_pool_size/innodb_buffer_pool_instances \u0026gt;= 1G innodb_buffer_pool_instances = 1 # 说明：mysql 5.7 新特性，defines the chunk size for online InnoDB buffer pool resizing operations. # 实际缓冲区大小必须为innodb_buffer_pool_chunk_size*innodb_buffer_pool_instances*倍数，取略大于innodb_buffer_pool_size # 默认值128M，建议值：默认值就好，乱改反而容易出问题，它会影响实际buffer pool大小。 innodb_buffer_pool_chunk_size = 128M # 在启动时把热数据加载到内存。默认值为on，不修改 innodb_buffer_pool_load_at_startup = 1 # 在关闭时把热数据dump到本地磁盘。默认值为on，不修改 innodb_buffer_pool_dump_at_shutdown = 1 # 说明：影响Innodb缓冲区的刷新算法，建议从小到大配置，直到zero free pages；innodb_lru_scan_depth * innodb_buffer_pool_instances defines the amount of work performed by the page cleaner thread each second. # 默认值1024，建议值: 未知 innodb_lru_scan_depth = 1024 # 说明：事务等待获取资源等待的最长时间，单位为秒，看具体业务情况，一般默认值就好 # 默认值：50，建议值：看业务。 innodb_lock_wait_timeout = 60 # 说明：设置了Mysql后台任务（例如页刷新和merge dadta from buffer pool）每秒io操作的上限。 # 默认值：200，建议值：方法一，单盘sata设100，sas10，raid10设200，ssd设2000，fushion-io设50000；方法二，通过测试工具获得磁盘io性能后，设置IOPS数值/2。 innodb_io_capacity = 2000 # 说明：该参数是所有缓冲区线程io操作的总上限。 # 默认值：innodb_io_capacity的两倍。建议值：例如用iometer测试后的iops数值就好 innodb_io_capacity_max = 4000 # 说明：控制着innodb数据文件及redo log的打开、刷写模式，三种模式：fdatasync(默认)，O_DSYNC，O_DIRECT # fdatasync：数据文件，buffer pool-\u0026gt;os buffer-\u0026gt;磁盘；日志文件，buffer pool-\u0026gt;os buffer-\u0026gt;磁盘； # O_DSYNC： 数据文件，buffer pool-\u0026gt;os buffer-\u0026gt;磁盘；日志文件，buffer pool-\u0026gt;磁盘； # O_DIRECT： 数据文件，buffer pool-\u0026gt;磁盘； 日志文件，buffer pool-\u0026gt;os buffer-\u0026gt;磁盘； # 默认值为空，建议值：使用SAN或者raid，建议用O_DIRECT，不懂测试的话，默认生产上使用O_DIRECT innodb_flush_method = O_DIRECT # 说明：mysql5.7之后默认开启，意思是，每张表一个独立表空间。 # 默认值1，开启 innodb_file_per_table = 1 # 说明：The path where InnoDB creates undo tablespaces.通常等于undo log文件的存放目录。 # 默认值./;自行设置 innodb_undo_directory = /usr/local/mysql8/log # 说明：5.7.5后开始使用，在线收缩undo log使用的空间。 # 默认值：关闭，建议值：开启 innodb_undo_log_truncate = 1 # 说明：结合innodb_undo_log_truncate，实现undo空间收缩功能 # 默认值：1G，建议值，不改。 innodb_max_undo_log_size = 1G # 说明：重作日志文件的存放目录 innodb_log_group_home_dir = /usr/local/mysql8/log # 说明：日志文件的大小 # 默认值:48M,建议值：根据你系统的磁盘空间和日志增长情况调整大小 innodb_log_file_size = 128M # 说明：日志组中的文件数量，mysql以循环方式写入日志 # 默认值2，建议值：根据你系统的磁盘空间和日志增长情况调整大小 innodb_log_files_in_group = 3 # 此参数确定些日志文件所用的内存大小，以M为单位。缓冲区更大能提高性能，但意外的故障将会丢失数据。MySQL开发人员建议设置为1－8M之间 innodb_log_buffer_size = 16M # 说明：可以控制log从系统buffer刷入磁盘文件的刷新频率，增大可减轻系统负荷 # 默认值是1；建议值不改。系统性能一般够用。 innodb_flush_log_at_timeout = 1 # 说明：参数可设为0，1，2； # 参数0：表示每秒将log buffer内容刷新到系统buffer中，再调用系统flush操作写入磁盘文件。 # 参数1：表示每次事物提交，将log buffer内容刷新到系统buffer中，再调用系统flush操作写入磁盘文件。 # 参数2：表示每次事物提交，将log buffer内容刷新到系统buffer中，隔1秒后再调用系统flush操作写入磁盘文件。 innodb_flush_log_at_trx_commit = 1 # 说明：限制Innodb能打开的表的数据，如果库里的表特别多的情况，请增加这个。 # 值默认是2000，建议值：参考数据库表总数再进行调整，一般够用不用调整。 innodb_open_files = 8192 # innodb处理io读写的后台并发线程数量，根据cpu核来确认，取值范围：1-64 # 默认值：4，建议值：与逻辑cpu数量的一半保持一致。 innodb_read_io_threads = 4 innodb_write_io_threads = 4 # 默认设置为 0,表示不限制并发数，这里推荐设置为0，更好去发挥CPU多核处理能力，提高并发量 innodb_thread_concurrency = 0 # 默认值为4，建议不变。InnoDB中的清除操作是一类定期回收无用数据的操作。mysql 5.5之后，支持多线程清除操作。 innodb_purge_threads = 4 # 说明：mysql缓冲区分为new blocks和old blocks；此参数表示old blocks占比； # 默认值：37，建议值，一般不动 innodb_old_blocks_pct = 37 # 说明：新数据被载入缓冲池，进入old pages链区，当1秒后再次访问，则提升进入new pages链区。 # 默认值：1000 innodb_old_blocks_time=1000 # 说明：开启异步io，可以提高并发性，默认开启。 # 默认值为1，建议不动 innodb_use_native_aio = 1 # 说明：默认为空，使用data目录，一般不改。 innodb_data_home_dir=/usr/local/mysql8/data # 说明：Defines the name, size, and attributes of InnoDB system tablespace data files. # 默认值，不指定，默认为ibdata1:12M:autoextend innodb_data_file_path = ibdata1:12M:autoextend # 说明：The crash recovery mode。只有紧急情况需要恢复数据的时候，才改为大于1-6之间数值，含义查下官网。 # 默认值为0； #innodb_force_recovery = 0 ########################################################################################################## # 其他。。。。 # 参考http://www.kuqin.com/database/20120815/328905.html # skip-external-locking # 禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。 # 缺点：所有远程主机连接授权都要使用IP地址方式，因为只认得ip地址了。 # skip_name_resolve = 0 # 默认值为off,timestamp列会自动更新为当前时间，设置为on|1，timestamp列的值就要显式更新 explicit_defaults_for_timestamp = 1 [mysqldump] # quick选项强制 mysqldump 从服务器查询取得记录直接输出而不是取得所有记录后将它们缓存到内存中 quick max_allowed_packet = 16M [mysql] # mysql命令行工具不使用自动补全功能，建议还是改为 # no-auto-rehash auto-rehash socket = /tmp/mysql.sock 创建my.cnf后\n# 切换到安装目录 cd /usr/local/mysql8 # 创建相关文件 mkdir data log chown -R mysql:mysql data log # 初始化mysql, --defaults-file的参数就是刚才创建的配置文件, --basedir的参数就是mysql安装目录, --datadir的参数就是mysql数据目录 ./bin/mysqld --defaults-file=/etc/my.cnf --initialize --user=mysql --basedir=/usr/local/mysql8/ --datadir=/usr/local/mysql8/data/ # 会返回类似代码 [System] [MY-013169] [Server] /usr/local/mysql8/bin/mysqld (mysqld 8.0.20) initializing of server in progress as process 48055 [System] [MY-013576] [InnoDB] InnoDB initialization has started. [System] [MY-013577] [InnoDB] InnoDB initialization has ended. [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: =tsSl-.Wt3ud # \u0026#34;root@localhost:\u0026#34; 后边跟着就是mysql为root生成的临时密码,记下来,开启mysql后,可以用这个密码登录(如果没返回上述代码,则查看日志,如: vim log/mysql-error.log) 开启并修改root密码\ncd /usr/local/mysql8 # 开启mysql ./support-files/mysql.server start # 登录并输入刚才记下的临时密码 ./bin/mysql -uroot -p # 修改root密码 mysql\u0026gt; alter user \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#34;123456\u0026#34;;  笔记三: 开关mysql cd /usr/local/mysql8 # 开启mysql进程 ./bin/mysqld -u mysql # 关闭mysql进程 ./bin/mysqladmin -uroot shutdown # 开启mysqld的守护进程,实际上是开启mysqld,当mysqld意外关闭时,mysqld_safe自动重启mysqld(可添加--skip-grant-tables参数,root可免密登录) ./bin/mysqld_safe --user=mysql \u0026amp; # 关闭mysqld的守护进程 ./bin/mysqladmin -uroot shutdown # 开启mysql服务,实际是开启mysqld_safe ./support-files/mysql.server start # 关闭mysql服务 ./support-files/mysql.server stop # 登录mysql ./bin/mysql -uroot -p # 软连接(软连接的源文件路径要写成绝对路径) ln -s /usr/local/mysql8/bin/* /usr/local/bin/ # 启动设置 cp support-files/mysql.server /etc/init.d/mysql.server ","date":1590842836,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1615666223,"objectID":"a8854f7aa114e47213193628111b86b3","permalink":"https://twbworld.github.io/post/install_mysql8_note/","publishdate":"2020-05-30T20:47:16+08:00","relpermalink":"/post/install_mysql8_note/","section":"post","summary":"最近试着安装做新版的mysql,过程中出现一些坎坷,所以记录下来","tags":["Mysql"],"title":"Centos源码安装Mysql8笔记","type":"post"},{"authors":["忐忑"],"categories":null,"content":" 最近想建立自己的博客网站,便于在开发过程中写一些笔记;\n但进入了未知领域,面临了怎么抉择的问题; 毕竟谁也不情愿一开始就因选择了自己不适合的,最后半途而悔\n 平台的选择 进入我的备选名单的有:\n CSDN 博客园 WordPress Github Pages 知乎  先讲结论,我最终选择了Github Pages\nWordPress 优点:\n 自己搭建的博客,自由度非常高 历经多年,插件丰富 对phper友好PHP  缺点:\n 浪费大量 时间 / 精力 / 金钱 去维护网站(服务器的维护,域名,SEO,还有服务器安全方面的考虑,等等)   时间宝贵,老子只想静静的写文章,不愿在无意义的事上浪费有限的时间\n 知乎 优点:\n 前端界面较前卫 平台的文章质量也很高,也有大量的程序猿聚集在此 平台流量大,本人平时也喜欢逛知乎,有些许个人感情  缺点:\n 平台信息有点杂,文章五花八门,而且这几年很多在知乎上带节奏,以及一些搞营销的,比较反感 知乎对MarkDown的支持不友好  CSDN/博客园 优点:\n CSDN/博客园 的搜索引擎优化是做的不错 程序猿社区,专注于技术博客,不像知乎给人的感觉很杂  缺点:\n 平台界面老旧(点名批评博客园,强迫症看着难受) CSDN的下载文件有收费模式 内容限制于平台,插广告都困难  Github Pages 优点:\n 使用Git管理 静态网站,比较好维护 搜索引擎优化,服务器的维护等等这些,全权交给github好了,不需要浪费过多的精力 自由度较高,可以使用各种主题和插件,没有平台限制,插广告放个\u0026quot;看板娘\u0026quot;啥的 可使用自己的域名,且免费支持https 写博客使用MarkDown,就要有图床;可使用Github仓库作为图床,托管图片和静态资源 如果搭配GitHub Actions的免费CI/CD服务(即push代码即可实现部署代码等工作), 那么 Git仓库 + 图床 + CI/CD 都在GitHub的生态下, 体验一级棒 Github是未来[呐喊], Github是未来[呐喊], Github是未来[呐喊]  缺点:\n gh-pages屏蔽了百度蜘蛛,用百度搜索引擎无法搜索出Github Pages的文章(但另一方面,百度相比Google的搜索质量差太多了;有\u0026quot;条件\u0026quot;的程序猿都善用Google吧?)解决办法并不是没有,zeit.co 可提供CDN服务    如果您也决定使用gh-pages搭建博客,那就会面临着一个选择, 博客框架/静态网站生成器 的选择(强迫症又要犯了!)\n 博客框架的选择  我所理解的静态网站生成器: 在生成器框架下写MarkDown文章,使用生成器把MarkDown文章编译成生成HTML\n 主流选择也就那么几个:\n Jekyll Hexo VuePress Hugo  先讲结论,经一番思想斗争,本人选择了Hugo\nJekyll Jekyll是GitHub创始人使用Ruby写的,同时也是gh-Pages默认的静态网站生成器\n但其速度较慢,特别是文章多的时候,特别明显\nHexo Hexo是js写的,js的用户群体较大,Hexo中文文档比较齐全,国内获得了较大的使用人群\nVuePress 较新的静态网站生成器,热度也不低,但同时也不太稳定; 其名可知,对熟悉Vue的同学较为友好,且Vue在交互性上有巨大的优势\nHugo 优点:\n 天下武功唯快不破,使用golang开发; 即使应对庞大的文章生成量,速度是用秒来计算的,简直秒杀对手 \u0026ldquo;Google出品,必属精品\u0026rdquo;,相信Hugo会随着go的影响力在国内越走越远(本人也正有学go的想法) 一个技巧(专治\u0026quot;选择困难症\u0026quot;),利用了搜索引擎来对比了Hexo和Hugo的搜索热度,Hugo的相关文章数是Hexo的100多倍,全球用户量庞大,Hugo所可选的博客模板也不少   缺点:\n 虽然全球用户量庞大,但缺乏中文文档, 国内用户群体少, Hugo的相关中文文章也就少; Hugo会不会是在国内的一支\u0026quot;潜力股\u0026quot; ?  ","date":1589713607,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1615666223,"objectID":"c3e6d11235ee0e46e122e956febaf5d6","permalink":"https://twbworld.github.io/post/blog_ready/","publishdate":"2020-05-17T19:06:47+08:00","relpermalink":"/post/blog_ready/","section":"post","summary":"最近想建立自己的博客网站,面临了抉择的问题,到底选择那个平台,用什么方式写技术博客","tags":["Github"],"title":"搭建博客的准备","type":"post"},{"authors":["忐忑"],"categories":null,"content":"1#费用 月付  如想要更低的价 , 或者 担心每月忘记续费 , 可选择 年付\n    流量(G/月) 价格(￥)     50 9   100 15   250 29   500 49    年付 年付8折计算 以 100G/月 为例计算 :\n15(元/月) X 12(月) X 0.8(折扣) = 144(元/年)\nPS  现在 , 可免费试用1个月, 50-100g不等 (亏本吖) 如果月底前就把流量用光了, 联系可免费续10%流量 如果觉得可以, 把我推荐给身边的朋友哟, 可适当奖励哟 每月1号流量重新开始算, 所以请在1号前续费 Fq 后,可做啥?  2#联系 +wx: twbhub\n3#教程 Android 点击下载\niOS 点击下载\nWindows 点击下载\nmacOS 点击下载\n","date":1614009600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1615666223,"objectID":"f508f68ab254acb5dce96f76f843b3e7","permalink":"https://twbworld.github.io/post/proxy/","publishdate":"2021-02-23T00:00:00+08:00","relpermalink":"/post/proxy/","section":"post","summary":"proxy","tags":null,"title":"订阅","type":"post"}]