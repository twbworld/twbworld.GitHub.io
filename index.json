[{"authors":["admin"],"categories":null,"content":" PHP小白 码农 韭菜 社畜  ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":1601195276,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://twbworld.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"PHP小白 码农 韭菜 社畜","tags":null,"title":"忐忑","type":"authors"},{"authors":["忐忑"],"categories":null,"content":" 有些小伙伴手里有上百G甚至上T移动硬盘\n平时制作启动硬盘,除了启动分区,都是只剩一个分区提供自己使用的\n那么问题来了:怎么保留启动盘的功能,又能把硬盘分成多个分区呢?\n搜索引擎也很少有相关文章\n那么,今天就带大家制作一个多分区启动盘\n作者尝试了无数次才成功的,呕心沥血之作\n 所使用到的:\n  硬盘(本文章使用U盘展示,建议硬盘,毕竟日常生活中的十几或几十G的U盘,也没必要进行分区了)\n  微PE(作者使用的版本是2.1;也可以使用\u0026quot;大白菜\u0026quot;或\u0026quot;老毛桃\u0026quot;,有广告植入,不建议)\n   微PE下载(不需要安装): http://www.wepe.com.cn/download.html\n  UltraISO(作者使用的版本是9.7)   UltraISO下载: https://cn.ultraiso.net/xiazai.html\n  DiskGenius(作者使用的版本是5.1)   DiskGenius下载: https://www.diskgenius.cn/download.php\n 1#获取微PE的系统ISO (1) 双击打开下载好的 微PE 安装包,看到以下界面,单击右下角的光盘图标 (2) 接下来,要把 微PE 自带的ISO镜像保存到电脑,选择保存的位置, 光盘卷标 也就是盘符的名称,也建议改成喜欢的名称,如\u0026quot;pe盘\u0026quot;,最后点击 立即生成ISO 2#写入ISO到硬盘 (1) 插入硬盘,准备格式化\n PS: 备份数据!!!!!备份数据!!!!!备份数据!!!!!\n (2) 打开安装好的 UltraISO ,菜单栏依次点击 文件-\u0026gt;打开 ; 选择上一步保存好的ISO文件\n(3) 可以看到,左侧栏出现的ISO文件\n(4) 接着,菜单栏依次点击 启动-\u0026gt;写入硬盘映像 (5) 出现一个弹窗, 硬盘驱动器 选择正确的硬盘,首先,需要把硬盘格式化,点击格式化 (6) 最后,正式把ISO文件写入硬盘,点击 写入 3#备份启动分区 (1) 打开安装好的 DiskGenius ,在左侧栏找到对应的硬盘,单击选中上一步生成的盘 (2) 菜单栏依次点击 工具-\u0026gt;备份分区到镜像文件 (3) 出现一个弹窗, 点击 选择文件路径 ,选择一个目录,输入自定义的pmf文件的名称,点击 打开 (4) 点击 开始 ,成功后,会生成一个.pmf后缀文件,这个文件就是你的启动盘备份文件 4#硬盘分区 (1) DiskGenius 左侧栏选中对应的硬盘,点击 快速分区 (2) 可以看到一个弹窗;这一步是成功的关键,要严格按照以下的规定(作者经过无数次的尝试,得出来的结论) :\n  分区表类型 一定为 MBR ; 不要问为什么,我也不知道 分区数目 最多为3个; 不要问为什么,我也不知道 高级设置 以第一个作为启动分区,所以第一个分区选择 FAT32, 其余为 NTFS ; 不要问为什么,我也不知道 高级设置 把所有的 主分区 勾上; 不要问为什么,我也不知道 至于各分区的容量,卷标名称等,请自定义    (3) 分区后,可以看到作为启动分区已经显示 活动 了 5#恢复启动分区 (1) DiskGenius ,在左侧栏找到对应的硬盘,单击选中上一步作为启动的分区 (2) 菜单栏依次点击 工具-\u0026gt;从镜像文件还原分区 (3) 出现弹窗, 点击 选择文件 , 选择在 第三步 生成的 pmf 文件 (4) 到此为止,成功制作了一个 多分区启动硬盘\n 但是,这样制作的多分区启动硬盘, BIOS 只能使用 Legacy 启动模式来启动硬盘(新型的 UEFI 无法启动PE), 如下图例子(华硕的BIOS)\n \u0026hellip; 以上\n","date":1601302813,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1601302813,"objectID":"bda3981c485475de00f23b31448a0805","permalink":"https://twbworld.github.io/post/2020/09/28/multi_partition_startup_disk/","publishdate":"2020-09-28T22:20:13+08:00","relpermalink":"/post/2020/09/28/multi_partition_startup_disk/","section":"post","summary":"一般制作启动盘后,只有一个大分区?如何制作多个分区的启动盘","tags":["System"],"title":"制作多分区启动盘","type":"post"},{"authors":["忐忑"],"categories":null,"content":" 连接局域网下的虚拟机,在网上找到的做法通常是:在VMware配置端口转发\n最近了解隧道技术,突发奇想:能不能使用SSH隧道连接局域网下的虚拟机呢?\n在网上找到的相关资料不多,经过自己摸索,终于实现了\n使用SSH隧道连接局域网下的虚拟机,主要有两种方式可以实现\n1: 本地端口转发; 2: 动态端口转发\n 首先,假设网络图如下,A和B在同一局域网下,我们的目的是: 实现 A 连接到 C 的SSH服务 方法一 : 本地端口转发  大体思路: 在A下创建 A --\u0026gt; C 的SSH隧道,就可以访问A下的指定端口,通过隧道转发,访问到C的22端口了\n具体实现如下 :\n 1#B安装SSH服务  参考文章 https://www.cnblogs.com/sparkdev/p/10166061.html\n   这是非常关键的一步(作为小白,我刚开始就异想天开,直接就想通过A连接到C,直到多次尝试失败并且想通了)\n  我的电脑 B 的系统是windows10 1909,自带了OpenSSH Server软件;如果版本是wondows10 1809以下或wondows7的同学,可以网上搜索windows怎么安装openSSH服务\n  (1) Win10打开 设置(Win + I) ==\u0026gt; 应用 ==\u0026gt; 应用和功能 ==\u0026gt; 可选功能 =\u0026gt; 添加功能 =\u0026gt; OpenSSH服务器(点击安装)\n(2) 打开 任务管理器(Shift + Ctrl + Esc) ==\u0026gt; 任务 ==\u0026gt; 左下角点击\u0026quot;打开服务\u0026quot;; 找到两个OpenSSH服务,右键开启\n(3) 打开 控制面板 ==\u0026gt; 系统和安全 ==\u0026gt; Windows Defender 防火墙 ==\u0026gt; 启用或关闭windows defender防火墙;选择关闭防火墙; (或者在入站规则添加允许22端口)\n 到此, B已经配置完成\n 2#A建立 A --\u0026gt; C 的隧道   本人使用的是PuTTY的工具, 使用其他工具或PowerShell也是可以的\n  首先保证 C 关闭iptables或nftables防火墙 (或配置允许22端口)\n  通过\u0026quot;中间人\u0026quot; B ; 在 A 电脑上使用PuTTY建立起与 C 的SSH隧道 (本地端口转发)\n  在 A 上配置(基于文章开头假设的网络图) :\n  点击open,会出现登录,注意:这里登录的是 B 电脑,也就是要输入B的windows的用户名和密码;\n  到这里,你已经建立起 A --\u0026gt; C 的隧道了, 注意: 请不要关闭PuTTY窗口, 否则隧道会被关闭\n   PuTTY如上设置,相当于使用命令 ssh -L 127.0.0.1:6666:192.168.2.2:22 192.168.1.107\n 3#A通过隧道连接 C 电脑  终于到最后一步了, 很简单, 在 A 电脑开启新的PuTTY窗口, 请求 A 本地的 刚才自定义的 6666端口就可以啦   恭喜你, 成功通过SSH隧道连接到 C ;因为隧道是 A --\u0026gt; C 的且加密的, B 不会监听到流量  方法二 : 动态端口转发  大体思路: 在A下创建 A --\u0026gt; B 的SSH隧道,把 B 作为代理(Proxy), 就可以实现 : A 使用SOCKS5协议通过 B 来访问到 C 的22端口\n具体实现如下 :\n 1#B安装SSH服务 (在 方法一 中有具体实现, 略)\n2#A建立 A --\u0026gt; B 的隧道   本人使用的是PuTTY的工具, 使用其他工具或PowerShell也是可以的\n  在 A 电脑上使用PuTTY建立起与 B 的SSH隧道 (动态端口转发)\n  在 A 上配置(基于文章开头假设的网络图) :\n  点击open,会出现登录,注意:这里登录的是 B 电脑,也就是要输入B的windows的用户名和密码;\n  到这里,你已经建立起 A --\u0026gt; B 的隧道了, 注意: 请不要关闭PuTTY窗口, 否则隧道会被关闭\n   PuTTY如上设置,相当于使用命令 ssh -D 127.0.0.1:6666 192.168.1.107\n 3#A通过代理连接 C 电脑  终于到最后一步了, 很简单, 在 A 电脑上开启新的PuTTY窗口, 设置 A 本地的 刚才自定义的 6666端口为代理端口, 请求 C 就可以啦  方法三 : VMware配置端口转发  这是一个比较普遍的做法, 在网上也容易找到相关文章\n大体思路: 在VMware上配置 监听父windows的端口X,把A端口转发到VMware下的虚拟机端口Y, 局域网的电脑只有访问windows的端口X就相当于访问虚拟机的端口Y啦, 是不是很容易\n具体实现如下 :\n 1#B配置VMware 2#B配置防火墙  打开 控制面板 ==\u0026gt; 系统和安全 ==\u0026gt; Windows Defender 防火墙 ==\u0026gt; 启用或关闭windows defender防火墙;选择关闭防火墙; (或者在 入站规则 添加允许 上一步自定义的6666端口)  3#A通过 B 连接 C 电脑  终于到最后一步了, 很简单, 在 A 电脑直接用PuTTY请求 B 的 6666端口, 就可以登录 C 啦  \u0026hellip; 以上\n","date":1594549093,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1594572344,"objectID":"7905d7c95ce016c8c96fb33ccc68e0f3","permalink":"https://twbworld.github.io/post/2020/07/12/use_tunnel_to_connect_to_virtual_machines_in_the_lan/","publishdate":"2020-07-12T18:18:13+08:00","relpermalink":"/post/2020/07/12/use_tunnel_to_connect_to_virtual_machines_in_the_lan/","section":"post","summary":"使用SSH隧道技术,连接局域网下的VMware linux虚拟机","tags":["Tunnel"],"title":"SSH隧道连接局域网下的虚拟机","type":"post"},{"authors":["忐忑"],"categories":null,"content":" 我的VMware版本: 15.5.2\n 一 创建虚拟网络  VMware菜单==\u0026gt;编辑==\u0026gt;虚拟网络编辑器  (这一步可略过)移除所有默认的\u0026quot;网络\u0026quot;  点击\u0026quot;添加网络\u0026quot;, 选择\u0026quot;VMnet8\u0026quot;    上方列表点击选择刚才添加的网络\u0026quot;VMnet8\u0026quot;; 选择NAT模式; 设置子网IP;一般设置\u0026quot;192.168.xxx.0\u0026quot;,我这设置为\u0026quot;192.168.2.0\u0026quot; 设置子网掩码\u0026quot;255.255.255.0\u0026quot;,一般子网掩码固定;    点击\u0026quot;NAT设置\u0026quot;;设置\u0026quot;网关IP\u0026quot;, 一般为\u0026quot;192.168.xxx.1\u0026quot;, 所以我这设置网关为\u0026quot;192.168.2.1\u0026quot;;点击\u0026quot;确定\u0026quot; (还有端口转发,一般用于局域网PC链接VMware里的虚拟机所使用)  点击\u0026quot;DHCP设置\u0026quot;; 这里可以设置网关分配给VMware下的虚拟机的起始IP和结束IP; 因为网关已经占用了192.168.xxx.1,所以这自定义起始IP可以为\u0026quot;192.168.xxx.2\u0026quot;, 结束IP为\u0026quot;192.168.xxx.254\u0026quot;, 点击\u0026quot;确认\u0026quot;, 回到上一层, 再次点击\u0026quot;确认\u0026quot;;  二 使用虚拟网络  查看 控制面板==\u0026gt;网络和Internet==\u0026gt;网络和共享中心==\u0026gt;更改适配器设置; 可看到, 虚拟网卡已创建成功;  选择新添加的网卡;右键选择\u0026quot;属性\u0026quot;;双击\u0026quot;协议版本4\u0026quot;;设置IP;我这里设置了100;也可以设大一点,点击\u0026quot;确认\u0026quot;   如果缺少这一步,可能会出现宿主机SSH链接不上虚拟机的情况(或者出现需要长时间才连通,连上后,短时间内又断开的情况);原因可能是因为网卡的IP占用了网关IP\u0026quot;192.168.xxx.1\u0026quot;, 导致虚拟机的数据到不了在外一层的宿主机\n 虚拟网卡已创建成功,最后还要选择使用新创建的网卡;选择你要使用刚才新建网卡的虚拟机, 右键选择\u0026quot;设置\u0026quot;, \u0026ldquo;硬件\u0026rdquo;==\u0026gt;\u0026ldquo;网络适配器\u0026rdquo; ,右侧点击\u0026quot;自定义:特定虚拟网络\u0026quot;, 选择新建的\u0026quot;VMnet8(NAT 模式)\u0026quot;, 点击\u0026quot;确定\u0026quot;   这一步非常关键,我曾经缺少这一步,导致虚拟机连不上网\n 到此,虚拟机应该就可以上网了,如果不行;请重启虚拟机的network; 或者VMware最右下角的\u0026quot;网络适配器\u0026quot;重新连接  同时还可以在虚拟机里设置固定的IP,IP地址要根据\u0026quot;起始IP\u0026quot;和结束\u0026quot;IP\u0026quot;设置; 例如,我在Centos8系统上, 设置了IP:\u0026ldquo;192.168.2.2\u0026rdquo;  ","date":1590905260,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1590917485,"objectID":"8706b532d563b46d6b0e3d569a55ef87","permalink":"https://twbworld.github.io/post/2020/05/31/vmware_customize_network/","publishdate":"2020-05-31T14:07:40+08:00","relpermalink":"/post/2020/05/31/vmware_customize_network/","section":"post","summary":"VMware创建设置虚拟网卡,可更好的了解和定制虚拟机的网络","tags":["VMware"],"title":"VMware自定义虚拟网卡(添加网络)","type":"post"},{"authors":["忐忑"],"categories":null,"content":"笔记一: 安装时,发生警告 --character-set-server: \u0026#39;utf8\u0026#39; is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous --collation-server: \u0026#39;utf8_general_ci\u0026#39; is a collation of the deprecated character set UTF8MB3. Please consider using UTF8MB4 with an appropriate collation instead 原因 :\n 安装mysql8的时候,配置了官方不推荐的\u0026quot;utf8\u0026quot;,其实\u0026quot;utf8\u0026quot;就是mysql中\u0026quot;UTF8MB3\u0026quot;的别名,然而又同时存在着\u0026quot;UTF8MB4\u0026quot;,所有,建议改为\u0026quot;UTF8MB4\u0026quot;;\n 解决 :\n 把cmake的参数 -DDEFAULT_CHARSET=utf8 改为 -DDEFAULT_CHARSET=utf8mb4  , -DDEFAULT_COLLATION=utf8_general_ci 改为 -DDEFAULT_COLLATION=utf8mb4_unicode_ci\n 给出完整cmake命令 :\n# 切换到mysql8解压后的目录 cd /usr/local/mysql8/ # 新建并切换build目录 mkdir build cd build # 编译前的配置;其中的\u0026#34;DCMAKE_INSTALL_PREFIX\u0026#34;, \u0026#34;DMYSQL_DATADIR\u0026#34;, \u0026#34;DWITH_BOOST\u0026#34; 按照自己的情况配置 cmake .. -DCMAKE_INSTALL_PREFIX=/usr/local/mysql8 \\ -DMYSQL_DATADIR=/usr/local/mysql8/data \\ -DSYSCONFDIR=/etc \\ -DWITH_MYISAM_STORAGE_ENGINE=1 \\ -DWITH_INNOBASE_STORAGE_ENGINE=1 \\ -DWITH_MEMORY_STORAGE_ENGINE=1 \\ -DWTH_READLINE=1 \\ -DMYSQL_TCP_PORT=3306 \\ -DENABLED_LOCAL_INFILE=1 \\ -DWITH_PARTITION_STORAGE_ENGINE=1 \\ -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8mb4 \\ -DDEFAULT_COLLATION=utf8mb4_unicode_ci \\ -DWITH_BOOST=/usr/local/boost_1_70_0  安装后,可以看到 /etc/my.cnf 设置为 collation-server = utf8mb4_unicode_ci character-set-server = utf8mb4\n  笔记二: 创建my.cnf 在/etc目录下没有发现my.cnf(我的mysql版本是mysql-8.0.20), 只能自己创建了 :\nvim /etc/my.cnf\n # 客户端设置 [client] port = 3306 # 默认情况下，socket文件应为/usr/local/mysql/mysql.socket,所以可以ln -s xx /tmp/mysql.sock socket = /tmp/mysql.sock # 服务端设置 [mysqld] ########################################################################################################## # 基础信息 #Mysql服务的唯一编号 每个mysql服务Id需唯一 server-id = 1 #服务端口号 默认3306 port = 3306 # 启动mysql服务进程的用户 user = mysql ########################################################################################################## # 安装目录相关 # mysql安装根目录 basedir = /usr/local/mysql8 # mysql数据文件所在位置 datadir = /usr/local/mysql8/data # 临时目录 比如load data infile会用到,一般都是使用/tmp tmpdir = /tmp # 设置socke文件地址 socket = /tmp/mysql.sock ########################################################################################################## # 事务隔离级别，默认为可重复读（REPEATABLE-READ）。（此级别下可能参数很多间隙锁，影响性能，但是修改又影响主从复制及灾难恢复，建议还是修改代码逻辑吧） # 隔离级别可选项目：READ-UNCOMMITTED READ-COMMITTED REPEATABLE-READ SERIALIZABLE # transaction_isolation = READ-COMMITTED transaction_isolation = REPEATABLE-READ ########################################################################################################## # 数据库引擎与字符集相关设置 # mysql 5.1 之后，默认引擎就是InnoDB了 default_storage_engine = InnoDB # 内存临时表默认引擎，默认InnoDB default_tmp_storage_engine = InnoDB #数据库默认字符集,主流字符集支持一些特殊表情符号（特殊表情符占用4个字节） character-set-server = utf8mb4 #数据库字符集对应一些排序等规则，注意要和character-set-server对应 collation-server = utf8mb4_unicode_ci # 设置client连接mysql时的字符集,防止乱码 # init_connect='SET NAMES utf8' ########################################################################################################## # 数据库连接相关设置 # 最大连接数，可设最大值16384，一般考虑根据同时在线人数设置一个比较综合的数字，鉴于该数值增大并不太消耗系统资源，建议直接设10000 # 如果在访问时经常出现Too Many Connections的错误提示，则需要增大该参数值 max_connections = 10000 # 默认值100，最大错误连接数，如果有超出该参数值个数的中断错误连接，则该主机将被禁止连接。如需对该主机进行解禁，执行：FLUSH HOST # 考虑高并发场景下的容错，建议加大。 max_connect_errors = 10000 # MySQL打开的文件描述符限制，默认最小1024; # 当open_files_limit没有被配置的时候，比较max_connections*5和ulimit -n的值，哪个大用哪个， # 当open_file_limit被配置的时候，比较open_files_limit和max_connections*5的值，哪个大用哪个。 open_files_limit = 65535 # 注意：仍然可能出现报错信息Can't create a new thread；此时观察系统cat /proc/mysql进程号/limits，观察进程ulimit限制情况 # 过小的话，考虑修改系统配置表，/etc/security/limits.conf和/etc/security/limits.d/90-nproc.conf # MySQL默认的wait_timeout 值为8个小时, interactive_timeout参数需要同时配置才能生效 # MySQL连接闲置超过一定时间后(单位：秒，此处为1800秒)将会被强行关闭 interactive_timeout = 1800 wait_timeout = 1800 # 在MySQL暂时停止响应新请求之前的短时间内多少个请求可以被存在堆栈中 # 官方建议back_log = 50 + (max_connections / 5),封顶数为900 back_log = 900 ########################################################################################################## # 数据库数据交换设置 # 该参数限制服务器端，接受的数据包大小，如果有BLOB子段，建议增大此值，避免写入或者更新出错。有BLOB子段，建议改为1024M max_allowed_packet = 128M ########################################################################################################## # 内存，cache与buffer设置 # 内存临时表的最大值,默认16M，此处设置成128M tmp_table_size = 64M # 用户创建的内存表的大小，默认16M，往往和tmp_table_size一起设置，限制用户临师表大小。 # 超限的话，MySQL就会自动地把它转化为基于磁盘的MyISAM表，存储在指定的tmpdir目录下，增大IO压力，建议内存大，增大该数值。 max_heap_table_size = 64M # 表示这个mysql版本是否支持查询缓存。ps：SHOW STATUS LIKE 'qcache%'，与缓存相关的状态变量。 # have_query_cache # 在一个事务中binlog为了记录SQL状态所持有的cache大小 # 如果你经常使用大的,多声明的事务,你可以增加此值来获取更大的性能. # 所有从事务来的状态都将被缓冲在binlog缓冲中然后在提交后一次性写入到binlog中 # 如果事务比此值大, 会使用磁盘上的临时文件来替代. # 此缓冲在每个连接的事务第一次更新状态时被创建 binlog_cache_size = 1M #*** MyISAM 相关选项 # 指定索引缓冲区的大小, 为MYISAM数据表开启供线程共享的索引缓存,对INNODB引擎无效。相当影响MyISAM的性能。 # 不要将其设置大于你可用内存的30%,因为一部分内存同样被OS用来缓冲行数据 # 甚至在你并不使用MyISAM 表的情况下, 你也需要仍旧设置起 8-64M 内存由于它同样会被内部临时磁盘表使用. # 默认值 8M，建议值：对于内存在4GB左右的服务器该参数可设置为256M或384M。注意：该参数值设置的过大反而会是服务器整体效率降低！ key_buffer_size = 64M # 为每个扫描MyISAM的线程分配参数设置的内存大小缓冲区。 # 默认值128kb，建议值：16G内存建议1M，4G：128kb或者256kb吧 # 注意，该缓冲区是每个连接独占的，所以总缓冲区大小为 128kb*连接数；极端情况128kb*maxconnectiosns，会超级大，所以要考虑日常平均连接数。 # 一般不需要太关心该数值，稍微增大就可以了， read_buffer_size = 262144 # 支持任何存储引擎 # MySQL的随机读缓冲区大小，适当增大，可以提高性能。 # 默认值256kb；建议值：得参考连接数，16G内存，有人推荐8M # 注意，该缓冲区是每个连接独占的，所以总缓冲区大小为128kb*连接数；极端情况128kb*maxconnectiosns，会超级大，所以要考虑日常平均连接数。 read_rnd_buffer_size = 1M # order by或group by时用到 # 支持所有引擎，innodb和myisam有自己的innodb_sort_buffer_size和myisam_sort_buffer_size设置 # 默认值256kb；建议值：得参考连接数，16G内存，有人推荐8M. # 注意，该缓冲区是每个连接独占的，所以总缓冲区大小为 1M*连接数；极端情况1M*maxconnectiosns，会超级大。所以要考虑日常平均连接数。 sort_buffer_size = 1M # 此缓冲被使用来优化全联合(full JOINs 不带索引的联合) # 类似的联合在极大多数情况下有非常糟糕的性能表现,但是将此值设大能够减轻性能影响. # 通过 “Select_full_join” 状态变量查看全联合的数量 # 注意，该缓冲区是每个连接独占的，所以总缓冲区大小为 1M*连接数；极端情况1M*maxconnectiosns，会超级大。所以要考虑日常平均连接数。 # 默认值256kb;建议值：16G内存，设置8M. join_buffer_size = 1M # 缓存linux文件描述符信息，加快数据文件打开速度 # 它影响myisam表的打开关闭，但是不影响innodb表的打开关闭。 # 默认值2000，建议值：根据状态变量Opened_tables去设定 table_open_cache = 2000 # 缓存表定义的相关信息，加快读取表信息速度 # 默认值1400，最大值2000，建议值：基本不改。 table_definition_cache = 1400 # 该参数是myssql 5.6后引入的，目的是提高并发。 # 默认值1，建议值：cpu核数，并且\u0026lt;=16 table_open_cache_instances = 2 # 当客户端断开之后，服务器处理此客户的线程将会缓存起来以响应下一个客户而不是销毁。可重用，减小了系统开销。 # 默认值为9，建议值：两种取值方式，方式一，根据物理内存，1G —\u0026gt; 8；2G —\u0026gt; 16； 3G —\u0026gt; 32； \u0026gt;3G —\u0026gt; 64； # 方式二，根据show status like 'threads%'，查看Threads_connected值。 thread_cache_size = 16 # 默认值256k,建议值：16/32G内存，512kb，其他一般不改变，如果报错：Thread stack overrun，就增大看看, # 注意，每个线程分配内存空间，所以总内存空间。。。你懂得。 thread_stack = 512k ########################################################################################################## # 日志文件相关设置，一般只开启三种日志，错误日志，慢查询日志，二进制日志。普通查询日志不开启。 # 普通查询日志，默认值off，不开启 general_log = 0 # 普通查询日志存放地址 general_log_file = /usr/local/mysql8/log/mysql-general.log # 全局动态变量，默认3，范围：1～3 # 表示错误日志记录的信息，1：只记录error信息；2：记录error和warnings信息；3：记录error、warnings和普通的notes信息。 log_error_verbosity = 2 # 错误日志文件地址 log_error = /usr/local/mysql8/log/mysql-error.log # 开启慢查询 slow_query_log = 1 # 开启慢查询时间，此处为1秒，达到此值才记录数据 long_query_time = 3 # 检索行数达到此数值，才记录慢查询日志中 min_examined_row_limit = 100 # mysql 5.6.5新增，用来表示每分钟允许记录到slow log的且未使用索引的SQL语句次数，默认值为0，不限制。 log_throttle_queries_not_using_indexes = 0 # 慢查询日志文件地址 slow_query_log_file = /usr/local/mysql8/log/mysql-slow.log # 开启记录没有使用索引查询语句 log-queries-not-using-indexes = 1 # 开启二进制日志 log_bin = /usr/local/mysql8/log/mysql-bin.log # mysql清除过期日志的时间，默认值30*24*60*60， binlog_expire_logs_seconds=604800 # 如果二进制日志写入的内容超出给定值，日志就会发生滚动。你不能将该变量设置为大于1GB或小于4096字节。 默认值是1GB。 max_binlog_size = 1000M # binlog的格式也有三种：STATEMENT，ROW，MIXED。mysql 5.7.7后，默认值从 MIXED 改为 ROW # 关于binlog日志格式问题，请查阅网络资料 binlog_format = row # 默认值N=1，使binlog在每N次binlog写入后与硬盘同步，ps：1最慢 # sync_binlog = 1 ########################################################################################################## # innodb选项 # 说明：该参数可以提升扩展性和刷脏页性能。 # 默认值1，建议值：4-8；并且必须小于innodb_buffer_pool_instances innodb_page_cleaners = 4 # 说明：一般8k和16k中选择，8k的话，cpu消耗小些，selcet效率高一点，一般不用改 # 默认值：16k；建议值：不改， innodb_page_size = 16384 # 说明：InnoDB使用一个缓冲池来保存索引和原始数据, 不像MyISAM.这里你设置越大,你在存取表里面数据时所需要的磁盘I/O越少. # 在一个独立使用的数据库服务器上,你可以设置这个变量到服务器物理内存大小的60%-80% # 注意别设置的过大，会导致system的swap空间被占用，导致操作系统变慢，从而减低sql查询的效率 # 默认值：128M，建议值：物理内存的60%-80% innodb_buffer_pool_size = 512M # 说明:只有当设置 innodb_buffer_pool_size 值大于1G时才有意义，小于1G，instances默认为1，大于1G，instances默认为8 # 但是网络上有评价，最佳性能，每个实例至少1G大小。 # 默认值：1或8，建议值：innodb_buffer_pool_size/innodb_buffer_pool_instances \u0026gt;= 1G innodb_buffer_pool_instances = 1 # 说明：mysql 5.7 新特性，defines the chunk size for online InnoDB buffer pool resizing operations. # 实际缓冲区大小必须为innodb_buffer_pool_chunk_size*innodb_buffer_pool_instances*倍数，取略大于innodb_buffer_pool_size # 默认值128M，建议值：默认值就好，乱改反而容易出问题，它会影响实际buffer pool大小。 innodb_buffer_pool_chunk_size = 128M # 在启动时把热数据加载到内存。默认值为on，不修改 innodb_buffer_pool_load_at_startup = 1 # 在关闭时把热数据dump到本地磁盘。默认值为on，不修改 innodb_buffer_pool_dump_at_shutdown = 1 # 说明：影响Innodb缓冲区的刷新算法，建议从小到大配置，直到zero free pages；innodb_lru_scan_depth * innodb_buffer_pool_instances defines the amount of work performed by the page cleaner thread each second. # 默认值1024，建议值: 未知 innodb_lru_scan_depth = 1024 # 说明：事务等待获取资源等待的最长时间，单位为秒，看具体业务情况，一般默认值就好 # 默认值：50，建议值：看业务。 innodb_lock_wait_timeout = 60 # 说明：设置了Mysql后台任务（例如页刷新和merge dadta from buffer pool）每秒io操作的上限。 # 默认值：200，建议值：方法一，单盘sata设100，sas10，raid10设200，ssd设2000，fushion-io设50000；方法二，通过测试工具获得磁盘io性能后，设置IOPS数值/2。 innodb_io_capacity = 2000 # 说明：该参数是所有缓冲区线程io操作的总上限。 # 默认值：innodb_io_capacity的两倍。建议值：例如用iometer测试后的iops数值就好 innodb_io_capacity_max = 4000 # 说明：控制着innodb数据文件及redo log的打开、刷写模式，三种模式：fdatasync(默认)，O_DSYNC，O_DIRECT # fdatasync：数据文件，buffer pool-\u0026gt;os buffer-\u0026gt;磁盘；日志文件，buffer pool-\u0026gt;os buffer-\u0026gt;磁盘； # O_DSYNC： 数据文件，buffer pool-\u0026gt;os buffer-\u0026gt;磁盘；日志文件，buffer pool-\u0026gt;磁盘； # O_DIRECT： 数据文件，buffer pool-\u0026gt;磁盘； 日志文件，buffer pool-\u0026gt;os buffer-\u0026gt;磁盘； # 默认值为空，建议值：使用SAN或者raid，建议用O_DIRECT，不懂测试的话，默认生产上使用O_DIRECT innodb_flush_method = O_DIRECT # 说明：mysql5.7之后默认开启，意思是，每张表一个独立表空间。 # 默认值1，开启 innodb_file_per_table = 1 # 说明：The path where InnoDB creates undo tablespaces.通常等于undo log文件的存放目录。 # 默认值./;自行设置 innodb_undo_directory = /usr/local/mysql8/log # 说明：5.7.5后开始使用，在线收缩undo log使用的空间。 # 默认值：关闭，建议值：开启 innodb_undo_log_truncate = 1 # 说明：结合innodb_undo_log_truncate，实现undo空间收缩功能 # 默认值：1G，建议值，不改。 innodb_max_undo_log_size = 1G # 说明：重作日志文件的存放目录 innodb_log_group_home_dir = /usr/local/mysql8/log # 说明：日志文件的大小 # 默认值:48M,建议值：根据你系统的磁盘空间和日志增长情况调整大小 innodb_log_file_size = 128M # 说明：日志组中的文件数量，mysql以循环方式写入日志 # 默认值2，建议值：根据你系统的磁盘空间和日志增长情况调整大小 innodb_log_files_in_group = 3 # 此参数确定些日志文件所用的内存大小，以M为单位。缓冲区更大能提高性能，但意外的故障将会丢失数据。MySQL开发人员建议设置为1－8M之间 innodb_log_buffer_size = 16M # 说明：可以控制log从系统buffer刷入磁盘文件的刷新频率，增大可减轻系统负荷 # 默认值是1；建议值不改。系统性能一般够用。 innodb_flush_log_at_timeout = 1 # 说明：参数可设为0，1，2； # 参数0：表示每秒将log buffer内容刷新到系统buffer中，再调用系统flush操作写入磁盘文件。 # 参数1：表示每次事物提交，将log buffer内容刷新到系统buffer中，再调用系统flush操作写入磁盘文件。 # 参数2：表示每次事物提交，将log buffer内容刷新到系统buffer中，隔1秒后再调用系统flush操作写入磁盘文件。 innodb_flush_log_at_trx_commit = 1 # 说明：限制Innodb能打开的表的数据，如果库里的表特别多的情况，请增加这个。 # 值默认是2000，建议值：参考数据库表总数再进行调整，一般够用不用调整。 innodb_open_files = 8192 # innodb处理io读写的后台并发线程数量，根据cpu核来确认，取值范围：1-64 # 默认值：4，建议值：与逻辑cpu数量的一半保持一致。 innodb_read_io_threads = 4 innodb_write_io_threads = 4 # 默认设置为 0,表示不限制并发数，这里推荐设置为0，更好去发挥CPU多核处理能力，提高并发量 innodb_thread_concurrency = 0 # 默认值为4，建议不变。InnoDB中的清除操作是一类定期回收无用数据的操作。mysql 5.5之后，支持多线程清除操作。 innodb_purge_threads = 4 # 说明：mysql缓冲区分为new blocks和old blocks；此参数表示old blocks占比； # 默认值：37，建议值，一般不动 innodb_old_blocks_pct = 37 # 说明：新数据被载入缓冲池，进入old pages链区，当1秒后再次访问，则提升进入new pages链区。 # 默认值：1000 innodb_old_blocks_time=1000 # 说明：开启异步io，可以提高并发性，默认开启。 # 默认值为1，建议不动 innodb_use_native_aio = 1 # 说明：默认为空，使用data目录，一般不改。 innodb_data_home_dir=/usr/local/mysql8/data # 说明：Defines the name, size, and attributes of InnoDB system tablespace data files. # 默认值，不指定，默认为ibdata1:12M:autoextend innodb_data_file_path = ibdata1:12M:autoextend # 说明：The crash recovery mode。只有紧急情况需要恢复数据的时候，才改为大于1-6之间数值，含义查下官网。 # 默认值为0； #innodb_force_recovery = 0 ########################################################################################################## # 其他。。。。 # 参考http://www.kuqin.com/database/20120815/328905.html # skip-external-locking # 禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。 # 缺点：所有远程主机连接授权都要使用IP地址方式，因为只认得ip地址了。 # skip_name_resolve = 0 # 默认值为off,timestamp列会自动更新为当前时间，设置为on|1，timestamp列的值就要显式更新 explicit_defaults_for_timestamp = 1 [mysqldump] # quick选项强制 mysqldump 从服务器查询取得记录直接输出而不是取得所有记录后将它们缓存到内存中 quick max_allowed_packet = 16M [mysql] # mysql命令行工具不使用自动补全功能，建议还是改为 # no-auto-rehash auto-rehash socket = /tmp/mysql.sock 创建my.cnf后\n# 切换到安装目录 cd /usr/local/mysql8 # 创建相关文件 mkdir data log chown -R mysql:mysql data log # 初始化mysql, --defaults-file的参数就是刚才创建的配置文件, --basedir的参数就是mysql安装目录, --datadir的参数就是mysql数据目录 ./bin/mysqld --defaults-file=/etc/my.cnf --initialize --user=mysql --basedir=/usr/local/mysql8/ --datadir=/usr/local/mysql8/data/ # 会返回类似代码 [System] [MY-013169] [Server] /usr/local/mysql8/bin/mysqld (mysqld 8.0.20) initializing of server in progress as process 48055 [System] [MY-013576] [InnoDB] InnoDB initialization has started. [System] [MY-013577] [InnoDB] InnoDB initialization has ended. [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: =tsSl-.Wt3ud # \u0026#34;root@localhost:\u0026#34; 后边跟着就是mysql为root生成的临时密码,记下来,开启mysql后,可以用这个密码登录(如果没返回上述代码,则查看日志,如: vim log/mysql-error.log) 开启并修改root密码\ncd /usr/local/mysql8 # 开启mysql ./support-files/mysql.server start # 登录并输入刚才记下的临时密码 ./bin/mysql -uroot -p # 修改root密码 mysql\u0026gt; alter user \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#34;123456\u0026#34;;  笔记三: 开关mysql cd /usr/local/mysql8 # 开启mysql进程 ./bin/mysqld -u mysql # 关闭mysql进程 ./bin/mysqladmin -uroot shutdown # 开启mysqld的守护进程,实际上是开启mysqld,当mysqld意外关闭时,mysqld_safe自动重启mysqld(可添加--skip-grant-tables参数,root可免密登录) ./bin/mysqld_safe --user=mysql \u0026amp; # 关闭mysqld的守护进程 ./bin/mysqladmin -uroot shutdown # 开启mysql服务,实际是开启mysqld_safe ./support-files/mysql.server start # 关闭mysql服务 ./support-files/mysql.server stop # 登录mysql ./bin/mysql -uroot -p # 软连接(软连接的源文件路径要写成绝对路径) ln -s /usr/local/mysql8/bin/* /usr/local/bin/ # 启动设置 cp support-files/mysql.server /etc/init.d/mysql.server ","date":1590842836,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1590917485,"objectID":"a8854f7aa114e47213193628111b86b3","permalink":"https://twbworld.github.io/post/2020/05/30/install_mysql8_note/","publishdate":"2020-05-30T20:47:16+08:00","relpermalink":"/post/2020/05/30/install_mysql8_note/","section":"post","summary":"最近试着安装做新版的mysql,过程中出现一些坎坷,所以记录下来","tags":["Mysql"],"title":"Centos源码安装Mysql8笔记","type":"post"},{"authors":["忐忑"],"categories":null,"content":" 最近想建立自己的博客网站,便于在开发过程中记录一些笔记;\n但是每次进入一个未知的领域,我的强迫症就会犯了,面临了抉择的问题;毕竟每个人都不想一开始就选择了不适合自己的,学到一半才后悔最初的选择;\n 平台的选择 进入我的备选名单的有:\n CSDN 博客园 WordPress Github Pages 知乎  先讲结论,我最终选择了Github Pages\nWordPress 优点:\n 自己搭建的博客,自由度非常高 历经多年,插件丰富 因为工作原因,个人比较熟悉PHP  缺点:\n 会浪费自己的大量精力和时间去维护网站(服务器的维护,域名,SEO,还有服务器安全方面的考虑,等等)  所有不好意思,程序员的时间非常宝贵,不要把时间浪费在这种无意义的事情上,我只想静静的写博客文章\n知乎 优点:\n 网站设计比较前卫 平台的文章质量也很高,也有大量的程序员聚集在此 个人原因,平时也喜欢逛逛知乎的热榜,消磨时间,感情上挺适合我胃口的  缺点:\n 知乎这个平台信息有点杂,文章五花八门,而且这几年很多在知乎上带节奏,以及一些搞营销的,比较反感 听说知乎的MarkDown支持的不太好  所有,只能忍痛割爱了\nCSDN和博客园 优点:\n 很明显,CSDN和博客园的搜索引擎优化是做的非常不错的 程序员这个物种比较多 专注于技术博客,不像知乎给人的感觉很杂  缺点:\n 平台太难看,设计太老旧了,点名批评博客园,强迫症看着难受 在CSDN居然有下载收费的模式,反感 限制太严格,卖个广告收不行  Github Pages 优点:\n 可以使用Git管理,这是必杀技啊 静态网站,比较好维护 搜索引擎优化,服务器的维护等等这些,全权交给github好了,咋们不需要浪费过多的精力 自由度比较高,可以使用各种各样的主题和插件,没有平台限制,可以卖个广告,放个收款码,放个看板娘啥的 可使用自己的域名,而且提供免费https证书 写博客,当然要使用MarkDown语法,而要很好的使用MarkDown,就要有自己的图床;正好可以使用Github仓库作为图床,托管自己的图片和静态资源;简直是完美的衔接 Github代表了未来,Github代表了未来,Github代表了未来  缺点:\n Github Pages屏蔽了百度蜘蛛,用百度搜索引擎无法搜索出Github Pages的文章(但是,从另外一方面想,百度搜索出来的结果本来就是垃圾,也不必讨好你.只要不屏蔽Google就行),不过解决办法也不是没有,就是使用cdn, zeit.co 可提供这样的服务    如果您也决定使用Github Pages搭建自己的个人博客,那么你就会面临着另外的一个选择(强迫症又要犯了)\n 博客框架的选择  我的理解博客框架就是:静态网站生成器;简单理解就是:按照它的规则,写MarkDown文章,它再把MarkDown格式的文章生成HTML\n 主流选择也就那么几个:\n Jekyll Hexo Hugo  先讲结论,经过一番思想斗争,我最终选择了Hugo\nJekyll Jekyll是使用Ruby写的,同时也是Github Pages默认的静态网站生成器\n被我pass了的原因主要是:看到网上的人说,Jekyll速度比较慢,特别是到后期\nHexo Hexo是js写的,因为这个原因,很多人使用Hexo也没压力,优点也很明显, 国内使用的人数比较多,中文文档比较齐全(当时看Hugo的文档,看得我头都疼)\nHugo Hugo是使用golang写的\n优点:\n 天下武功真的唯快不破,由于使用go开发的,go语言天生的速度优势,生成静态文件也就几秒的时间 golang是Google推出的,\u0026ldquo;Google出品,必属精品\u0026rdquo;,历史证明,golang也确实能当大任 由于在之前就想学golang了,Hugo正合我意 我用了一个笨方法(当\u0026quot;选择困难症\u0026quot;发作的时候,我经常使用,哈哈),利用了搜索引擎来对比了Hexo和Hugo关键词的搜索热度,结果发现,Hugo的相关文章数量是Hexo的一百多倍,Hugo使用的人更多,可能是代表未来   ","date":1589713607,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1590917485,"objectID":"c3e6d11235ee0e46e122e956febaf5d6","permalink":"https://twbworld.github.io/post/2020/05/17/blog_ready/","publishdate":"2020-05-17T19:06:47+08:00","relpermalink":"/post/2020/05/17/blog_ready/","section":"post","summary":"最近想建立自己的博客网站,面临了抉择的问题,到底选择那个平台,什么方式写技术博客","tags":["Hugo","Github-Pages"],"title":"搭建博客的准备","type":"post"}]